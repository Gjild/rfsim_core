I am making an MNA RF Circuit simulator in Python. I will provide the project description, implementation phases, and codebase. I have implemented up to and including phase 9 (ALL test files and folders are hidden in the codebase for brevity). Your job is to elegantly, robustly, and thoughtfully implement Phase 10 Task 1. Your implementation MUST be written comprehensively in GREAT DETAIL AND DEPTH, skipping no detail.

Project Description:

---

Important Note: This project is UNRELEASED! It has NO CURRENT USERS that may need to migrate or convert to adapt to whatever is created here!!!

**RFSim Core: Implementation of Linear RF Circuit Simulation (Revised & Enhanced)**
	
RFSim Core provides a foundational engine focused on establishing a robust basis for linear, passive RLC, and Subcircuit analysis in the frequency domain, with particular attention to rigorous ideal element and DC behavior. Developed in Python, its primary function is the calculation of network parameters (S, Y, Z, etc.) based on circuit topology and component behavior across a defined frequency sweep. While the long-term vision includes capabilities for linearized active components, transmission lines, and small-signal analysis, the intrinsic component library in this initial phase is deliberately constrained to ideal Resistors, Inductors, Capacitors, and the Subcircuit element, serving as a well-defined starting point. The primary output of RFSim Core is the raw numerical simulation data accessible via its Python API, intended for use by higher-level tools or direct programmatic access. This specification details key aspects focusing on validation, unit handling, numerical considerations, and extensibility, now reflecting enhanced robustness and precision in core functionalities.

**Technical Implementation Details:**

**Circuit Description (YAML Netlist) & Rigorous Validation:**

Circuit topology is defined using structured YAML netlist files.
*   Components are specified by type, unique ID, and a list of ports mapped to named electrical nodes ("nets").
*   External circuit interfaces are defined as "external ports," each assigned a complex reference impedance (constant or frequency-dependent expressions via the parameter system).

A **comprehensive, multi-stage validation pipeline** executes *before* simulation setup, designed to catch configuration errors early and definitively:
1.  **Schema Validation (Cerberus):** Verifies structural correctness of the YAML against a defined schema.
2.  **Semantic Validation (Custom Python):** Performs crucial checks for logical and topological consistency:
	*   Uniqueness of component and net IDs.
	*   Verification against registered component types (built-in or plugins).
	*   Validation of port existence and count consistency between component type definition and instance usage. Each component port must connect to exactly one net.
	*   **Refined Net Connectivity Analysis:** Identifies internal nets (not the ground net, not connected to external ports) connected to **fewer than two** component ports, issuing a warning by default (configurable to error). This covers both floating nets (zero ports) and single connections, which are common user errors.
	*   Checks for valid external port definitions and ground net validity/connectivity.
	*   **Component Parameter Validation (Dimensional & Expression):** Verifies instance parameters match declared component parameters. Uses Pint to evaluate parameter expressions, producing `pint.Quantity` objects. Confirms the resulting physical dimension is *compatible* with the dimension declared by the component type for that parameter. **The supported subset of mathematical functions and operations within parameter expressions for which dimensional consistency is guaranteed is explicitly documented and rigorously tested.**
	*   **Ideal DC Path Identification:** Identifies nodes connected by networks of ideal DC shorts. This includes *explicitly defined* ideal resistors (`R=0`), ideal inductors (`L=0`), and component ports explicitly marked as DC shorts. This informs the crucial DC node merging step. *Note: Near-zero numerical values are treated as finite impedances, not ideal shorts.*

**Parameter Management & Unit Handling Contract:**

A sophisticated parameter resolution engine supports global and instance-level parameters.
*   Values can be constants or string-based mathematical expressions potentially dependent on other parameters and frequency (`freq`).
*   **Expression Evaluation:** Expressions are parsed and securely compiled using `sympy.lambdify` with `modules='numpy'`. This converts symbolic expressions into efficient Python functions operating on NumPy arrays, enabling vectorized evaluation across sweeps. The frequency (`freq`) is passed as a NumPy array (in Hz) to these functions. Robust error handling catches parsing/evaluation issues. Supported functions are extensible. **These compiled parameter evaluation functions are cached for efficient reuse across sweeps and instances.**
*   **First-Class Unit Handling (Pint) & Strict Contract:**
	*   Parameters *should* be defined with units (e.g., `10 nH`, `50 ohm`). Pint enforces dimensional compatibility during expression evaluation based on the documented supported subset.
	*   **Parameter Resolution Lifecycle:** Parsing -> Compilation (`lambdify`, cached) -> Dependency Resolution (across hierarchy) -> Batched Evaluation across sweep points (using compiled functions and Pint) -> Produces `pint.Quantity` objects (scalars or arrays).
	*   **Component Interface Contract (Rigorous):**
		1.  **Input:** Component models are **required to declare the expected physical dimensions** (e.g., `'ohm'`) for their parameters. During simulation setup/update, they receive the resolved parameter values as **`pint.Quantity` objects**.
		2.  **Output:** Component models are **required to return matrix contributions (stamps or sub-matrices) as `pint.Quantity` objects whose base dimension is [admittance]**. The framework **strictly enforces this contract at runtime** by checking the returned Quantity's dimension. The numerical magnitude, automatically converted to base SI units (Siemens), is then extracted and used directly in the MNA matrix assembly. This guarantees dimensional correctness of MNA contributions.

**Hierarchical Design (Subcircuits) with Cross-Hierarchy Resolution:**

Supports hierarchical design via subcircuit components referencing other YAML netlists.
*   **Explicit Namespacing:** Parameters and nodes use explicit, dot-separated hierarchical names (e.g., `subckt1.R1.value`) for unambiguous referencing. Global parameters might use a distinct prefix or namespace.
*   Parameter mapping/overriding across hierarchy includes rigorous Pint-based dimensional compatibility checks.
*   Integrated global dependency tracking and circular dependency detection operate on fully qualified names. **Enhanced Diagnostic messages** for parameter errors include the full hierarchical name, definition location, the specific value/expression causing the issue, and error context, facilitating debugging in complex designs.

**Sweep Configuration:**

Defines simulation points via YAML configuration.
*   Supported sweeps: frequency (linear/log scale, range/list), parameter sweeps (list/range). Frequency specified with units (via Pint), converted internally to Hz NumPy arrays.
*   **Sweepable Parameters:** Parameters intended for sweeping must be marked `sweepable: true` in their netlist definition. This allows sweeping constants or derived parameters defined by expressions. The sweep config simply lists the names of these marked parameters and their sweep values/ranges.

**Simulation Core (MNA and Solver) & Robust Reduction:**

Utilizes Modified Nodal Analysis (MNA), with a dedicated path for DC analysis.

*   **Topological DC Pre-processing & Analysis (F=0):** Before any frequency sweeps are processed, a graph algorithm analyzes the circuit topology to identify nodes connected by ideal DC shorts (`R=0`, `L=0`, or marked DC shorts) and merges them into effective nodes. Simultaneously, nodes/sub-circuits isolated by ideal DC opens (`C=inf`, `L=inf`, or marked DC opens) are identified. A separate, reduced nodal analysis system is then formulated and solved *specifically* for the DC (F=0) case on this topologically simplified circuit.
*   **F > 0 MNA Matrix Assembly:** For frequency points F > 0, the standard MNA matrix is assembled in the admittance domain (Siemens). Component models calculate their frequency-dependent stamp contributions (as dimensioned `pint.Quantity` objects) which are strictly validated and converted to Siemens before insertion. Optimized sparse assembly (e.g., COO format -> CSR/CSC) is used. Ground node handled automatically.
*   **Handling F > 0 Ideals:** For frequency points F > 0, cases where component models calculate infinite admittance (`L=0`, `C=inf` at F>0) are handled by substituting a **configurable large finite admittance**. Cases where models calculate zero admittance (`L=inf`, `C=0` at F>0) are handled naturally by the sparse matrix structure (zero entries). These numerical substitutions apply *only* to F > 0 points and are distinct from the rigorous DC analysis.
*   **Efficient Topological Floating Node Removal:** **Before frequency sweeps begin**, a topological analysis (e.g., graph traversal from ground/ports) identifies nodes or sub-circuits that are disconnected from the solvable network by ideal opens or components exhibiting zero admittance *across the entire sweep range* (e.g., `L=inf`, `C=0`). These topologically floating structures are removed from the MNA system structure *before* frequency-dependent matrix assembly for any sweep point, improving efficiency and preventing singularities.
*   **Numerical Handling:** Uses `numpy.complex128`. Employs SciPy sparse solvers (`lu_factor`, `lu_solve`) and considers matrix pre-conditioning (equilibration) to improve stability for circuits with wide impedance variations.
*   **Enhanced Singularity/Conditioning Checks:**
	*   Leverages solver diagnostics (e.g., near-zero pivots) for initial checks.
	*   Provides an *optional* (`estimate_condition_number: true`) check using `scipy.sparse.linalg.onenormest` (or similar) after factorization to estimate the matrix condition number, issuing warnings above a configurable threshold.
	*   **Crucially, upon detecting near-singularity**, the system performs a topological analysis of the relevant circuit sub-graph based on the calculated component admittances at that frequency. Diagnostic messages include identification of specific nodes or circuit regions (e.g., shorted loops, isolated branches) likely causing the numerical instability, providing actionable insight for debugging.
*   **Solution & Parameter Conversion:** Solves the internal MNA system for node voltages. Reduces solution to external ports (e.g., Schur complement). Provides a rigorously tested module for converting the resulting N-port Y-matrix to S, Z, H, or G parameters, correctly handling arbitrary complex port reference impedances.

**Performance Optimization:**

*   **Vectorized Evaluation:** Parameter evaluation and component model calculations are designed for vectorized operation using NumPy arrays.
*   **Caching:** Caching of compiled parameter evaluation functions and caching sparse matrix structure/LU factorization pattern for frequency sweeps enable fast updates/solves.
*   **Parallelization:** Sweep points are parallelized using `concurrent.futures`.

**Component Extensibility (Plugin System) with Defined and Enforced API:**

Includes a plugin system for custom linear component models.
*   **Discovery:** Uses standard Python packaging **entry points** (e.g., `rfsim_core.components`) for discovery.
*   **Strict API Contract:**
	*   Custom components inherit from a base class.
	*   Must declare expected parameter dimensions (Pint strings).
	*   Receive resolved parameters as `pint.Quantity` objects.
	*   The primary calculation method (e.g., `get_stamps`) receives the frequency array (`freq_hz: np.ndarray`). **Implementations are expected to be vectorized.**
	*   **Crucially, must return contributions as `pint.Quantity` objects with the [admittance] dimension.** The framework **enforces this dimension requirement at runtime** upon receiving the contributions.
	*   Base class provides **utilities** for simplified stamping (e.g., `add_admittance_stamp(n1, n2, admittance_quantity_array)`) that handle index manipulation and perform the internal unit conversion to Siemens *after* the dimension check.

**Simulation Outputs:**

The primary output is **raw numerical data** (complex NumPy arrays for S/Y/Z etc. vs. sweep variables) accessible via the Python API. RFSim Core **does not include built-in writers for standard file formats** (e.g., Touchstone .sNp). This functionality is envisioned for higher-level tools built upon this core engine, allowing the core to remain focused on robust simulation calculation.

**Core Libraries Utilized:**

*   NumPy & SciPy: Numerical computation, sparse matrices/solvers, solver diagnostics, condition estimation, potentially graph algorithms for topological analysis.
*   SymPy: Secure expression parsing, `lambdify` for compilation to fast numerical functions.
*   Pint: Unit parsing, dimensional analysis, Quantity representation, strict unit enforcement.
*   PyYAML & Cerberus: Netlist parsing and schema validation.
*   concurrent.futures: Parallel execution.
*   importlib.metadata: Plugin discovery via entry points.

**Summary:**

RFSim Core provides a foundational Python library for frequency-domain linear circuit simulation, currently supporting R, L, C, and Subcircuits. It is built on a foundation of **rigorous validation (schema, semantic, dimensional), first-class unit handling via Pint with strict runtime enforcement**, and **robust MNA techniques including dedicated topological DC analysis, carefully managed F>0 ideal handling, efficient topological floating node removal, and enhanced singularity diagnostics providing actionable debugging information.** Performance is addressed through vectorized evaluation (SymPy/NumPy), parallelization, and caching of compiled functions and matrix structures. Extensibility is provided via a standard entry-point plugin system with a clear and **strictly enforced API contract**. By delivering raw numerical results via its API, RFSim Core serves as a verifiable, extensible, and robust engine designed for incorporation into broader RF simulation and analysis workflows.

---

Implementation Phases:

---

**Project Plan: RFSim Core**

**Phase 0: Project Setup & Foundation (The Groundwork)**

*   **Goal:** Set up the basic project structure, environment, dependencies, and version control.
*   **Tasks:**
	1.  Initialize Git repository.
	2.  Set up Python project structure (e.g., using `src` layout, `tests` directory).
	3.  Choose and configure a testing framework (e.g., `pytest`).
	4.  Set up virtual environment (`venv` or `conda`).
	5.  Create `requirements.txt` or `pyproject.toml` with initial core dependencies: `numpy`, `scipy`, `pint`, `pyyaml`, `cerberus`, `sympy`.
	6.  Set up basic logging.
	7.  Define initial core data structures (placeholder classes or dataclasses for `Circuit`, `Component`, `Net`, `Port`).
*   **Deliverable:** A runnable (but empty) Python package structure with testing configured.

**Phase 1: Basic Netlist Parsing & Schema Validation (Reading the Blueprint)**

*   **Goal:** Parse a simple YAML netlist containing only R, L, C components and external ports, validating its basic structure. Introduce basic unit handling for parameters.
*   **Tasks:**
	1.  Define a basic YAML schema using Cerberus covering:
		*   Top-level structure (`components`, `ports`, `parameters`).
		*   Component definition (type, id, ports map).
		*   External port definition (id, reference impedance - constant string only for now).
		*   Basic parameter definition (name, value - string/number only).
	2.  Implement a `NetlistParser` class that:
		*   Takes a YAML file path or string.
		*   Uses PyYAML to load the data.
		*   Uses Cerberus to validate against the schema. Raises informative errors on failure.
	3.  Implement basic `ParameterManager` capable of storing global constant parameters defined *with units* using Pint (e.g., `resistance: '10 ohm'`). Parse unit strings into `pint.Quantity` objects. No expressions yet.
	4.  Refine internal data structures (`Circuit`, `Component`, `Net`, `Port`) to store parsed information, including component parameters as strings initially.
*   **Deliverable:** A function/method that can read a simple RLC YAML netlist, validate its structure, and represent it internally. Basic parameter values with units are stored. Tests for valid and invalid schemas.

**Phase 2: Foundational Component Models & Parameter Resolution (The Building Blocks)**

*   **Goal:** Implement basic R, L, C component models adhering to the strict unit contract, and resolve their constant parameters.
*   **Tasks:**
	1.  Define a `ComponentBase` abstract base class.
	2.  Implement concrete `Resistor`, `Inductor`, `Capacitor` classes inheriting from `ComponentBase`.
	3.  **Component Contract Implementation (Part 1 - Input):**
		*   Components declare expected parameter dimensions (e.g., `Resistor` expects `'ohm'`).
		*   Implement logic (likely within a `CircuitBuilder` or similar) that:
			*   Retrieves the parameter *string* for a component instance.
			*   Uses the `ParameterManager` (enhanced slightly) to parse this string into a `pint.Quantity`.
			*   Checks if the resulting `Quantity`'s dimension is *compatible* with the dimension declared by the component type. Raises clear errors if not.
			*   Passes the validated `pint.Quantity` object to the component instance during setup.
	4.  **Component Contract Implementation (Part 2 - Output):**
		*   Implement a basic `get_admittance(freq_hz: float)` method on R, L, C.
		*   This method calculates the component's admittance (e.g., `1/R`, `1/(j*2*pi*f*L)`, `j*2*pi*f*C`).
		*   **Crucially, this method MUST return the admittance as a `pint.Quantity` with dimensions of `[admittance]` (e.g., Siemens).** Use Pint for calculations internally where appropriate.
*   **Deliverable:** R, L, C component classes that can be instantiated with validated, dimensionally-correct constant parameters (as `pint.Quantity` objects) and can calculate their admittance (as a `pint.Quantity`) at a single frequency. Tests for parameter validation and admittance calculation.

**Phase 3: Single-Frequency MNA Simulation (First Simulation!)**

*   **Goal:** Assemble and solve the MNA matrix for a simple RLC circuit at a *single* frequency (F > 0).
*   **Tasks:**
	1.  Implement an `MnaAssembler` class.
	2.  Assign unique integer indices to all nodes (nets), including ground (typically index 0). Map net names to indices.
	3.  Implement MNA matrix stamping logic within `MnaAssembler`:
		*   Iterate through components.
		*   Call the component's `get_admittance` method (passing the single frequency).
		*   **Enforce Contract:** Check that the returned value is a `pint.Quantity` with `[admittance]` dimension.
		*   Extract the magnitude of the admittance (in base SI units - Siemens) using `quantity.to_base_units().magnitude`.
		*   Add the appropriate conductance stamp (`G`, `-G`, `-G`, `G`) to the nodal admittance matrix (Yn) part of the MNA system using the node indices. Use sparse matrix formats (e.g., COO initially, then convert to CSR/CSC).
	4.  Handle external ports: Stamp their reference admittance (1/Z_ref) connecting the port node to ground. Store port node indices.
	5.  Implement a `Solver` class that:
		*   Takes the assembled sparse MNA matrix and the excitation vector (RHS). (Initially, excite one port with 1A, others 0A).
		*   Uses `scipy.sparse.linalg.splu` / `spsolve` to solve `Ax = b` for the node voltages (and branch currents if added later).
		*   Returns the solution vector.
	6.  Implement basic result extraction: Get the voltages at the external port nodes. Calculate the N-port Y-matrix from the port voltages and currents.
*   **Deliverable:** Ability to simulate a simple RLC circuit at one frequency point and get the resulting Y-matrix. Tests with known simple circuits (e.g., voltage divider).

**Phase 4: Frequency Sweeps & Basic Vectorization (Multiple Points)**

*   **Goal:** Extend the simulation to handle frequency sweeps (linear/log list) and leverage NumPy for vectorization.
*   **Tasks:**
	1.  Implement sweep configuration parsing (frequency lists/ranges with units). Convert to a NumPy array of frequencies in Hz.
	2.  Modify component `get_admittance` methods to accept `freq_hz: np.ndarray` and return `np.ndarray` of admittance `pint.Quantity` objects (or a single Quantity containing a NumPy array). Ensure calculations are vectorized.
	3.  Modify `MnaAssembler` and `Solver`:
		*   Loop through the frequency points.
		*   Inside the loop: Assemble the MNA matrix for the current frequency (using vectorized component results for that frequency if parameters are constant, or recalculating if parameters depend on `freq` - anticipate this).
		*   Solve for each frequency.
		*   Store the results (e.g., Y-matrix) for each frequency point.
	4.  Refactor the parameter system slightly to handle `freq` as a potential input (even if not used yet).
	5.  Implement basic caching of the sparse matrix structure (sparsity pattern) if it remains constant across the frequency sweep (which it should if only frequency changes).
*   **Deliverable:** Ability to simulate an RLC circuit across a frequency sweep and obtain the frequency-dependent Y-matrix. Tests comparing sweep results to single-point results.

**Phase 5: Parameter Expressions & Advanced Parameter Handling (Making it Dynamic)**

*   **Goal:** Implement the expression evaluation engine using SymPy/`lambdify` and handle parameter dependencies.
*   **Tasks:**
	1.  Enhance `ParameterManager`:
		*   Store parameters as expressions (strings).
		*   Implement dependency tracking (simple graph). Detect circular dependencies.
		*   Implement expression parsing and compilation using `sympy.lambdify(modules=['numpy', 'sympy'])`. Pass `freq` as a variable. Allow a defined subset of math functions. Handle parsing/compilation errors robustly.
		*   Cache compiled functions.
	2.  Integrate expression evaluation:
		*   When a component requests a parameter value, the `ParameterManager` resolves dependencies, evaluates the expression (passing the frequency array `freq`), potentially using Pint for dimensional consistency during evaluation if inputs have units.
		*   The result passed to the component is still a `pint.Quantity` (potentially containing a NumPy array).
	3.  Update component parameter validation to work with expression results. The dimension check happens *after* evaluation.
	4.  Document the supported mathematical functions and operators for expressions and their dimensional requirements/behavior.
*   **Deliverable:** Simulate circuits where component values are defined by frequency-dependent expressions. Tests for various expressions, dependency resolution, and error handling.

**Phase 6: Semantic Validation & Refined Connectivity (Catching User Errors)**

*   **Goal:** Implement the detailed semantic validation checks.
*   **Tasks:**
	1.  Implement the custom Python validation stage running *after* schema validation but *before* simulation setup.
	2.  Add checks for:
		*   Unique component/net IDs.
		*   Registered component types.
		*   Port existence/count consistency.
		*   **Refined Net Connectivity:** Find internal nets connected to < 2 ports (warning/error).
		*   Valid external port definitions.
		*   Ground net validity.
		*   **Component Parameter Dimensionality Check:** Re-verify this crucial check happens here systematically using the declared dimensions vs. evaluated expression dimensions.
*   **Deliverable:** A robust pre-simulation validation pipeline that catches common logical and topological errors. Extensive tests for each validation rule.

**Phase 7: Rigorous DC Analysis & Ideal Handling (The F=0 Case & Ideals)**

*   **Goal:** Implement the distinct DC (F=0) analysis path and handle ideal components correctly at F=0 and F>0.
*   **Tasks:**
	1.  **Ideal DC Path Identification:**
		*   Add flags/methods for components to declare if they act as DC shorts (e.g., `R=0`, `L=0`) or DC opens (`C=inf`, `L=inf`).
		*   Implement graph traversal algorithm to find nodes connected by ideal DC shorts.
	2.  **DC Pre-processing & Analysis:**
		*   Merge nodes identified as DC-shorted.
		*   Identify nodes/sub-circuits isolated by DC opens.
		*   Formulate and solve a *reduced* MNA system specifically for F=0 on the merged/simplified topology. Store the DC solution.
	3.  **F > 0 Ideal Handling:**
		*   In the main frequency loop (F > 0):
			*   If component `get_admittance` calculates near-infinite admittance, replace with a configurable large finite value.
			*   Zero admittance is handled naturally by sparsity.
	4.  **Topological Floating Node Removal:**
		*   *Before* the frequency sweep loop, perform graph traversal (from ground/ports) assuming worst-case opens (e.g., `C=0`, `L=inf`).
		*   Identify nodes/components completely disconnected from the ground/ports.
		*   Modify the MNA assembler to *exclude* these floating structures entirely from the matrix dimensions/assembly for all frequencies.
*   **Deliverable:** Correct handling of DC behavior, ideal components, and removal of structurally floating nodes, improving robustness and accuracy. Tests for DC shorts, opens, floating subcircuits.

!!! AT THIS POINT, THE PROJECT TAKES A MONUMENTAL LEAP !!!

### **Phase 8 (Definitive Architecture): Hierarchical Circuit Synthesis and Simulation**

**Architectural Mandate:** This plan establishes the definitive, principled architecture for hierarchical design in RFSim Core. It is founded on four non-negotiable tenets that guide every design decision, prioritizing correctness, clarity, and maintainability.

1.  **Correctness by Construction:** The system's primary responsibility is to produce verifiably correct results. The architecture is designed to make incorrect states impossible to represent or to catch them at the earliest possible stage through explicit contracts and data structures.
2.  **Explicit Contracts:** Each module has a single, unambiguous responsibility, enforced through strongly-typed data structures and clear ownership of data transformation. Raw, untyped dictionaries will not be used to pass structured data between major architectural components. This eliminates fragile, implicit contracts and promotes robust, maintainable code.
3.  **Simplicity Through Constraint:** The system is intentionally opinionated to eliminate ambiguity. By enforcing strict, reasonable constraints on user inputs—particularly on identifier naming conventions—we eradicate entire classes of complexity, resulting in a simpler, more predictable, and more reliable system.
4.  **Actionable Diagnostics:** Every user-facing error message must be a complete diagnostic tool. It must guide the user to the exact source of the problem with fully qualified names (FQNs), file paths, and the specific values or expressions that caused the failure, preserving the original exception for developer-level debugging.

This plan rectifies critical architectural flaws by introducing a correct-by-construction simulation caching strategy, an unambiguous identifier management system, and a clear, robust data flow from parsing to execution. This is the blueprint for a reliable and professional-grade hierarchical simulation capability.

**Detailed Implementation Tasks:**

#### **Task 1: YAML Syntax Definition for Subcircuits**

*   **Goal:** Define and formally specify the YAML syntax for instantiating subcircuits and update the master schema in `NetlistParser` to validate this syntax.

*   **1.1. Define `Subcircuit` Component in YAML:**
    *   Introduce a new component `type`: `Subcircuit`.
    *   The fields for a component of `type: Subcircuit` are:
        *   `id: <string>` (e.g., `X1`): The unique instance ID of the subcircuit within the parent circuit.
        *   `type: Subcircuit`: The mandatory type string.
        *   `definition_file: <string_path>`: The path to the subcircuit's YAML definition file. This path string will be resolved by `CircuitBuilder` in a later task, with the standard behavior being relative to the parent YAML file's directory.
        *   `ports: <dict>` (Optional): A dictionary that maps the external port names from the subcircuit's definition to the net names in the current parent circuit.
            *   Example: `ports: { SUBCKT_PORT_IN: parent_net1, SUBCKT_PORT_OUT: parent_net2 }`
            *   If the `ports` key is present, it must contain at least one mapping. If a subcircuit defines external ports, this block is semantically required (enforced by `SemanticValidator`).
        *   `parameters: <dict>` (Optional): A dictionary that provides override values for parameters within the subcircuit.
            *   Keys can be either interface parameters (defined in the subcircuit's top-level `parameters` block) or dot-separated "deep" overrides for internal components.
            *   Values must conform to the standard parameter schema (e.g., `"10kohm"` or `{expression: "...", dimension: "..."}`).

*   **1.2. Structure of a Subcircuit Definition YAML File:**
    *   A subcircuit definition file is a standard RFSim Core YAML netlist.
    *   It may define its own `ports` section to declare its external interface.
    *   It may define its own top-level `parameters` section to declare its interface parameters with default values.
    *   Any `sweep` section within a subcircuit definition file is ignored when it is instantiated as a subcircuit.

*   **1.3. Update Master Schema (`NetlistParser._schema`):**
    *   Create a new schema definition, `_subcircuit_component_schema`, dedicated to validating `Subcircuit` instances.
    *   The existing schema for R, L, C components will be encapsulated in `_standard_component_schema`.
    *   The main `components` list schema will be updated to use a `oneof_schema` rule, requiring that each component definition in the list must be valid against *either* the `_standard_component_schema` or the `_subcircuit_component_schema`.
    *   The `_subcircuit_component_schema` will define:
        *   `type`: `{ 'type': 'string', 'required': True, 'allowed': ['Subcircuit'] }`
        *   `id`: `{ 'type': 'string', 'required': True, 'empty': False }`
        *   `definition_file`: `{ 'type': 'string', 'required': True, 'empty': False }`
        *   `ports`: `{ 'type': 'dict', 'required': False, 'minlength': 1, 'keysrules': {'type': 'string'}, 'valuesrules': {'type': 'string'} }`
        *   `parameters`: `{ 'type': 'dict', 'required': False, 'keysrules': {'type': 'string'}, 'valuesrules': _param_value_schema }`

#### **Task 2: Data Structure Modifications for Hierarchy**

*   **Goal:** Update the core `Circuit` data structure and create a new `SubcircuitInstance` component class to represent hierarchical elements in the simulation model.

*   **2.1. `Circuit` Class (`data_structures.py`):**
    *   Add `source_file_path: Optional[Path] = None` to store the resolved absolute path to the YAML file that defines this circuit.
    *   Add `hierarchical_id: str = "top"` to store the fully qualified name of this circuit's context (e.g., `"top"`, `"top.X1"`). This is set by `CircuitBuilder` and defaults to `"top"` for the root circuit.
    *   The existing `parameter_manager` attribute will be typed as `Optional['ParameterManager']`.

*   **2.2. New `SubcircuitInstance` Component Class (`components/subcircuit.py`):**
    *   Create a new file `src/rfsim_core/components/subcircuit.py`.
    *   Define `class SubcircuitInstance(ComponentBase):` and register it with the component registry via `@register_component("Subcircuit")`.
    *   **Constructor `__init__(...)`:**
        *   The constructor will accept the following arguments to establish the instance's identity, connections, and context:
            *   `instance_id: str`: The ID of this subcircuit instance (e.g., `X1`).
            *   `parameter_manager: Optional[ParameterManager]`: The single, global `ParameterManager` for the entire simulation.
            *   `sub_circuit_object_ref: Circuit`: A reference to the fully built `Circuit` object representing the subcircuit's definition.
            *   `sub_circuit_external_port_names_ordered: List[str]`: The ordered list of the subcircuit definition's external port names. This order defines the N-port Y-matrix indexing.
            *   `parent_hierarchical_id: str`: **(Crucial)** The non-optional, fully qualified hierarchical ID of the parent circuit that contains this instance (e.g., `"top"`). This is essential for constructing the instance's own FQN.
            *   `raw_ir_data: ParsedSubcircuitData`: **(Crucial)** The non-negotiable link to the original parsed IR data for this specific instance, holding the raw port mappings and parameter overrides. **This field is essential for robust validation and caching and MUST NOT be `None`.**
        *   Implementation Note: The `parameter_manager` is handled by the base class constructor. The implementation must call `super().__init__(..., parameter_manager=parameter_manager, ...)` rather than creating a redundant instance attribute.
        *   Internal attributes will be set to store these arguments and to cache simulation results:
            *   `cached_y_parameters_ac: Optional[np.ndarray]` (Shape: NumFreqs x N x N)
            *   `cached_dc_analysis_results: Optional[Dict[str, Any]]`
    *   **`fqn` Property:**
        *   Implement a read-only property `@property def fqn(self) -> str:` that returns the canonical, fully qualified name of this instance (e.g., `"top.X1"`), constructed from `self.parent_hierarchical_id` and `self.instance_id`.
    *   **`declare_parameters(cls) -> Dict[str, str]`:** Returns an empty dictionary `{}`.
    *   **`declare_ports(cls) -> List[str | int]`:** Returns an empty list `[]`.
    *   **`declare_connectivity(cls) -> List[Tuple[str | int, str | int]]`:** Returns an empty list `[]`.
    *   **`get_mna_stamps(self, freq_hz: np.ndarray, resolved_params: Dict[str, Quantity], current_sweep_idx: Optional[int] = None) -> List[StampInfo]`:**
        1.  Assert that `self.cached_y_parameters_ac` has been populated by the simulation executive.
        2.  Assert that the `MnaAssembler` provides a valid `current_sweep_idx`.
        3.  Retrieve the N x N Y-matrix slice for the current frequency: `y_slice_mag = self.cached_y_parameters_ac[current_sweep_idx, :, :]`.
        4.  Return the stamp as a `StampInfo` tuple: `[(Quantity(y_slice_mag, ureg.siemens), self.sub_circuit_external_port_names_ordered)]`.
    *   **`get_dc_behavior(self, resolved_params: Dict[str, Quantity]) -> Tuple[DCBehaviorType, Optional[Quantity]]`:**
        1.  Assert that `self.cached_dc_analysis_results` is available.
        2.  Retrieve the cached DC Y-matrix, `y_ports_dc_qty = self.cached_dc_analysis_results.get('Y_ports_dc')`.
        3.  If `y_ports_dc_qty` is a valid `pint.Quantity`, return `(DCBehaviorType.ADMITTANCE, y_ports_dc_qty)`. Otherwise, return `(DCBehaviorType.OPEN_CIRCUIT, None)`.
    *   **`is_structurally_open(self, resolved_constant_params: Dict[str, Quantity]) -> bool`:** Returns `False`.

#### **Task 3: Foundational Refactoring for an Explicit Architecture**

*   **Goal:** Evolve the core data structures to explicitly represent the different stages of processing (parsing vs. synthesis), embed essential source location information for superior diagnostics, and establish type-safe, unbreakable contracts between all system components.

*   **3.1. Introduce an Explicit Intermediate Representation (IR):**
    *   A new file, `src/rfsim_core/parser/raw_data.py`, will be created.
    *   This module will define dataclasses that represent the direct, unlinked, schema-validated output of the parser (`ParsedCircuitNode`, `ParsedComponentData`, `ParsedSubcircuitData`, `ParsedLeafComponentData`). This abolishes the use of raw dictionaries for passing structured data between the parser and the builder. This IR is the formal, type-safe contract between these two critical stages.

*   **3.2. Refine Core Data Structures for Diagnostics and Consistency:**
    *   Modify `src/rfsim_core/data_structures.py` to refine the `Net` class. Its `fqn` property will be canonical, unifying all grounds under a single FQN (e.g., `"gnd"`).
    *   Modify `src/rfsim_core/parameters.py` to create the `ParameterDefinition` dataclass. This object is the explicit contract between the `CircuitBuilder` and `ParameterManager`, containing full context (`owner_fqn`, `base_name`, `raw_value_or_expression_str`, `source_yaml_path`, `declared_dimension_str`).

*   **3.3. Implement `NetlistParser` - The User-Friendly Interpreter:**
    *   Its sole public method is `parse_to_circuit_tree(self, yaml_path: Path) -> ParsedCircuitNode`.
    *   This method recursively parses the hierarchy of YAML files, detecting circular file dependencies.
    *   For each file, it instantiates the correct `ParsedComponentData` IR objects, populating them with schema-validated data, including the absolute `source_yaml_path`.
    *   It **MUST enforce a strict naming convention** via regex (e.g., `^[a-zA-Z_][a-zA-Z0-9_-]*$`). This regex **MUST** be applied in the Cerberus schema for **ALL** user-defined string identifiers (component 'id', circuit_name, parameter names, port IDs, net names, etc.). Forbidding the FQN separator (`.`) is a non-negotiable constraint for system simplicity and correctness.

*   **3.4. Implement `CircuitBuilder` - The Robust Model Synthesizer:**
    *   Its primary method `build_simulation_model(self, parsed_tree_root: ParsedCircuitNode)` transforms the IR tree into the final, linked `Circuit` model.
    *   It uses a **two-pass pipeline**:
        1.  **Pass 1 (Definition Collection):** Recursively traverses the IR tree to collect all `ParameterDefinition` objects. It **MUST** use `collections.ChainMap` to correctly manage lexical scoping for parameter resolution. For subcircuit overrides, it correctly sources the `declared_dimension_str` from the subcircuit's *original definition*.
        2.  **Pass 2 (Model Synthesis):** Instantiates the final `Circuit` and `ComponentBase` simulation objects, linking them to a single global `ParameterManager`. It performs **Ground Unification**, ensuring all nets named "gnd" (or the file-specific ground name) are linked to a single, canonical `Net` object.

#### **Task 4: Implement `ParameterManager` and `ExpressionPreprocessor` for FQN-Based Resolution**

*   **Goal:** Implement the simplified `ParameterManager` and the new `ExpressionPreprocessor` utility, which operate exclusively on the fully-contextualized data provided by the `CircuitBuilder`.

*   **4.1. Implement the `ExpressionPreprocessor` Utility:**
    *   Create `src/rfsim_core/parameters/preprocessor.py`.
    *   Implement the `ExpressionPreprocessor` class with a single public method: `preprocess(self, raw_expr: str, scope: ChainMap, reserved_keywords: Set[str]) -> sympy.Expr`.
    *   The implementation **MUST** be based on `ast.parse` and a custom `ast.NodeVisitor` subclass. This is a non-negotiable detail that ensures robust parsing without fragile string manipulation.
    *   The `visit_Name` and `visit_Attribute` methods will use the `scope` `ChainMap` to look up identifiers (e.g., `gain` or `amp1.R1.resistance`) and return `sympy.Symbol(<resolved_FQN>)`.
        *   Implementation Note for `visit_Attribute`: This method should contain a recursive helper that traverses the AST attribute chain (e.g., `node.value` which is another `Attribute` or `Name` node) to build up the full dot-separated string (e.g., `"sub1.R1.resistance"`) before performing a single lookup in the `scope`.
    *   If a lookup fails, it **MUST** raise a `ParameterScopeError` with comprehensive details, including the attempted resolution path.

*   **4.2. Refactor `ParameterManager` to Align with its Simplified Role:**
    *   Modify `ParameterManager.build()` to accept the flat list of `ParameterDefinition` objects and the `scope_maps: Dict[str, ChainMap]` from the `CircuitBuilder`. The `scope_maps` dictionary is keyed by the FQN of the parameter whose expression is being processed.
    *   **Delete all hierarchical search logic.** The method `_resolve_symbol_to_internal_name` is **removed**. The `ParameterManager` no longer understands scopes; it only understands FQNs.
    *   During its `build` process, when it encounters a `ParameterDefinition` that is an expression, it will:
        1.  Retrieve the correct `ChainMap` for that parameter's FQN from the `scope_maps` dictionary.
        2.  Instantiate and use the `ExpressionPreprocessor` to get a `sympy.Expr` object.
        3.  The `free_symbols` of this returned SymPy object are now guaranteed to be FQNs. Dependency tracking becomes a trivial check against the keys of the parameter context map.
    *   The `ParameterManager`'s internal data structures will now map FQNs to FQN dependencies. Its complexity is drastically reduced, and its correctness is guaranteed by its inputs.

#### **Task 5: Implement Recursive Simulation Execution and Caching**

*   **Goal:** Implement the recursive simulation execution flow with the correct-by-construction caching strategy.

*   **5.1. Implement the Top-Level `run_sweep` and Recursive Helper:**
    *   The public `run_sweep` function for the top-level circuit initializes an empty `simulation_cache: Dict[Tuple, Dict]`.
    *   It then calls the private recursive helper `_populate_subcircuit_caches_recursive(self, circuit_node: Circuit, ...)` which performs a depth-first traversal of the synthesized `Circuit` object tree.
    *   For each `SubcircuitInstance` it encounters, it first recurses on `sub_inst.sub_circuit_object`, then computes its *own* cache key and simulates if a cache miss occurs.

*   **5.2. Implement The Definitive Cache Key Algorithm:**
    *   Create the private helper function `_compute_subcircuit_cache_key(...)`.
    *   This function **MUST** implement the exact, non-negotiable key generation:
        `key = (def_path_str, canonical_overrides_tuple, external_context_tuple, frequency_array_tuple)`
        *   `def_path_str`: Absolute path to the subcircuit's definition file.
        *   `canonical_overrides_tuple`: A sorted, canonical representation of the parameter overrides from the instance's YAML.
        *   `external_context_tuple`: A canonical tuple of the **full definitions** (`fqn`, `raw_value_or_expression_str`, `declared_dimension_str`) of all external parameters the subcircuit depends on. This is found by traversing dependencies in the global `ParameterManager`.
        *   `frequency_array_tuple`: A sorted, unique tuple of the frequency points.
    *   **Note on Correctness:** This key is complex by design because it is **correct**. It guarantees no false cache hits. Do not be tempted to simplify it (e.g., by hashing values instead of definitions), as this would violate the "Correctness by Construction" mandate. The performance cost of this key is the explicit price of correctness.

*   **5.3. Implement Recursive `DCAnalyzer` and `TopologyAnalyzer`:**
    *   **DC Analysis:** The `DCAnalyzer`, when analyzing a parent circuit, will encounter `SubcircuitInstance` components. It will call their `get_dc_behavior` method, which will simply return the pre-computed and cached DC Y-matrix from `sub_inst.cached_dc_analysis_results`.
    *   **Topology Analysis:** The parent's `TopologyAnalyzer` will trigger a *separate, recursive* `TopologyAnalyzer` analysis on `sub_inst.sub_circuit_object`.
        *   This child TA determines which of the subcircuit's own external ports are connected through non-structurally-open paths. It returns a simple port-pair connectivity map.
        *   **Caching:** This connectivity map result **MUST** be cached within the scope of the top-level analysis. The key should be `(subcircuit_definition_file_path, canonical_tuple_of_its_internal_constant_parameter_values)`. This is because the internal topology only depends on its own constant parameters that define structural opens (e.g., `C=0`, `R=inf`). Persistent caching can be explored as a future optimization.

#### **Task 6: Update `MnaAssembler` to Stamp `SubcircuitInstance` Components**

*   **Goal:** Enable the `MnaAssembler` to correctly handle the `SubcircuitInstance` component type by using its defined API.

*   **6.1. Sparsity Pattern (`_compute_sparsity_pattern`):**
    *   For a `SubcircuitInstance`, the assembler will determine the set of parent nets it connects to via `sim_comp.raw_ir_data.raw_port_mapping`.
    *   It will add stamps to the pattern assuming **dense N-port connectivity** between this set of parent nets. This is a simple, robust approach that guarantees the pattern is sufficient and favors correctness over premature optimization.

*   **6.2. Matrix Assembly (`assemble`):**
    *   The `assemble` loop iterates through `_effective_sim_components`.
    *   When it encounters a `SubcircuitInstance sim_comp`, it does the following:
        1.  It calls `stamp_info_list = sim_comp.get_mna_stamps(..., current_sweep_idx=self.current_sweep_idx)`. It **must** pass the `current_sweep_idx` it is tracking.
        2.  The `SubcircuitInstance.get_mna_stamps` implementation (Task 2.2) is responsible for using the `current_sweep_idx` to select the correct `(N, N)` Y-matrix slice from its `cached_y_parameters_ac` array.
        3.  The assembler receives the `(admittance_matrix_qty, sub_circuit_external_port_names_ordered)` tuple.
        4.  It uses the `sub_circuit_external_port_names_ordered` list and the instance's port mapping data (from `raw_ir_data.raw_port_mapping`) to map the `(i, j)` entries of the Y-matrix to the correct `(parent_mna_idx_row, parent_mna_idx_col)` locations.

#### **Task 7: Implement Recursive Semantic Validation Using the IR**

*   **Goal:** Implement a recursive validator that leverages the synthesized model and its embedded links to the raw IR for comprehensive, contextual checks.

*   **7.1. Implement Recursive Validation Structure:**
    *   The `SemanticValidator`'s `validate()` method will call a private recursive helper `_validate_recursive(self, circuit_node: Circuit)`.
    *   The `circuit_node.hierarchical_id` is used to build FQNs for all reported issues, ensuring actionable diagnostics.

*   **7.2. Implement Subcircuit-Specific Checks:**
    *   When validating a `SubcircuitInstance sub_inst`, the validator will now access `sub_inst.raw_ir_data` and `sub_inst.sub_circuit_object`.
    *   It will implement checks such as:
        *   `SUB_PORT_MAP_UNDECLARED_TARGET` (ERROR): Checks that keys in `sub_inst.raw_ir_data.raw_port_mapping` are valid external port names in `sub_inst.sub_circuit_object.external_ports`.
        *   `SUB_PORT_MAP_MISSING_SOURCE` (ERROR): Checks that all required ports in `sub_inst.sub_circuit_object.external_ports` are mapped by the instance.
        *   `SUB_PORT_MAP_REQUIRED_BUT_OMITTED` (ERROR): Checks that if `sub_inst.sub_circuit_object.external_ports` is not empty, the instance's YAML definition *must* contain a `ports:` block.
        *   **Parameter Override Validation:** For each override in `sub_inst.raw_ir_data.raw_parameter_overrides`, it will check if the target parameter FQN exists. For constant literal overrides (e.g., `"1kohm"`), it will parse the literal and check its dimension against the *original declared dimension* of the parameter it's overriding. For expression overrides, validation is implicitly handled by the `ParameterManager`'s evaluation flow, which uses the correct target dimension provided by the `CircuitBuilder`.

#### **Task 8: Implement the Actionable Diagnostics Mandate**

*   **Goal:** Ensure all user-facing errors are complete diagnostic reports, as specified in the architectural mandate.
*   **Implementation:**
    1.  Wrap the main user-facing entry points (`build_simulation_model`, `run_sweep`) in a top-level `try...except Exception as e:` block.
    2.  This top-level handler **MUST** be context-aware. It should contain specific `except <ErrorType> as e:` blocks (e.g., `except ParameterScopeError`, `except pint.DimensionalityError`) to introspect the state and context from different exception types. Low-level components like the `ExpressionPreprocessor` must raise exceptions that carry this context.
    3.  The handler will use this context to construct the detailed, multi-line diagnostic report string precisely matching the format specified in the architectural mandate.
    4.  The new, user-friendly exception (`CircuitBuildError` or `SimulationError`) **MUST** be raised using exception chaining: `raise CircuitBuildError(diagnostic_report) from e`. This is non-negotiable.
    5.  The diagnostic report format must be as follows:
        ```
        CircuitBuildError: Parameter definition failed.

        ================ RFSim Core: Actionable Diagnostic Report ================
        Error Type:     Unresolved Symbol in Expression
        Parameter FQN:  top.amp1.L_match.inductance
        Source File:    /path/to/project/amplifier.yaml
        User Input:     "L_base * gain_factor"
        
        Details:
        The symbol 'gain_factor' could not be resolved.
        
        Resolution Path Searched:
        - Local Scope ('top.amp1'): 'gain_factor' not found.
        - Parent Scope ('top'): 'gain_factor' not found.
        - Global Scope ('_rfsim_global_'): 'gain_factor' not found.
        
        Suggestion:
        Please check the spelling of 'gain_factor' or define it in an 
        accessible scope (e.g., in the 'parameters' block of amplifier.yaml 
        or the top-level netlist).
        ========================================================================
        ```

### **Phase 9: A Capability-Based Component Model for a Multi-Domain Future**

#### **1. Introduction & Strategic Mandate**

**Topic:** This phase introduces a formal, queryable **"capability" system**, fundamentally evolving the component model API. This architecture definitively decouples analysis engines (like the MNA solver) from component implementations, allowing components to expose functionalities beyond basic MNA stamping in a scalable, extensible, and type-safe manner. This is the final and essential architectural enhancement required to establish a professional-grade, stable plugin API before expanding the simulator's feature set into new analysis domains.

**Strategic Justification (A Rejection of Misapplied YAGNI):** The "You Ain't Gonna Need It" (YAGNI) principle is a valuable heuristic for preventing speculative over-engineering. However, its application to this specific architectural decision would be a **strategic error**. The long-term vision for RFSim Core definitively includes analysis domains beyond the current linear frequency-domain simulation. These future domains include, but are not limited to:
*   **Noise Analysis:** Requiring components to provide noise current/voltage contributions.
*   **Harmonic Balance Analysis:** Requiring components to provide non-linear current-voltage relationships in the frequency domain.
*   **Transient Analysis:** Requiring components to define their behavior in the time domain, potentially via state-space models or differential equations.

This is not a question of *if* these capabilities will be needed, but *when*. The current monolithic `ComponentBase` interface—which would require adding a new abstract method (`get_noise_contribution`, `get_transient_behavior`, etc.) for each new analysis type—is a known **architectural dead end**. Continuing to build upon it would be a conscious accrual of technical debt, necessitating a far more disruptive, costly, and API-breaking refactoring in the future when the codebase is larger and more complex.

Therefore, this phase represents a **deliberate and strategic investment in the project's foundational architecture**. By implementing this superior design now, when the number of analysis domains is small (MNA, DC), we establish a clean, stable, and professional-grade plugin API. This ensures that the future addition of complex component behaviors and new analysis engines will be a process of elegant extension, not painful, breaking changes. This is **essential future-proofing, not idle speculation**.

#### **2. Architectural Mandates for the Capability System**

This implementation is guided by four non-negotiable architectural tenets that ensure its correctness, robustness, and usability.

1.  **Cohesion of Implementation:** All logic and all capability implementations related to a single conceptual component (e.g., a `Resistor`) **MUST** be co-located within that component's single class definition. This is achieved through the use of nested classes. This mandate strictly forbids scattering a component's logic across multiple, unrelated top-level classes or files, a practice which severely degrades maintainability, readability, and discoverability.

2.  **Declarative and Robust Registration:** A component **MUST** declare its capabilities declaratively through a class decorator (`@provides`). The system **MUST NOT** rely on developers manually populating a dictionary or list, as this is fragile, error-prone, and places an undue burden on the plugin author. The `ComponentBase` class will be responsible for automatically and robustly discovering registered capabilities by inspecting the full class hierarchy (Method Resolution Order, or MRO), correctly handling inheritance. This shifts the burden of correctness from the plugin author to the framework.

3.  **Decoupling through Queryable Interfaces:** Analysis engines **MUST NOT** assume that a component implements a specific method (e.g., `get_mna_stamps`). Instead, they **MUST** explicitly query a component instance for a specific capability (e.g., `component.get_capability(IMnaContributor)`). This contract, defined by a `typing.Protocol`, ensures that analysis engines are completely decoupled from the internal implementation of any given component, enabling true, scalable extensibility.

4.  **Explicit and Vectorized Context Passing:** Analysis engines are responsible for passing the full and necessary runtime context to a capability's methods. For performance-critical operations, this context **MUST** be vectorized to preserve the simulator's high-performance architecture. For example, the MNA pre-computation step will pass the **entire frequency array** to the `IMnaContributor` capability, which is contractually obligated to perform a **single, vectorized calculation** for all frequencies. This mandate prevents catastrophic performance regressions.

#### **3. Detailed Implementation Plan**

This plan is broken down into sequential, verifiable tasks.

##### **Task 1: Define the Foundational Capability Architecture**

*   **Goal:** Establish the core `Protocol` definitions and the declarative registration mechanism. This is the bedrock of the entire system.
*   **Justification:**
    *   **`typing.Protocol`:** This enables structural subtyping, also known as "static duck typing." It is architecturally superior to using `abc.ABC` for this purpose because it enforces an interface contract without forcing a class to inherit from a specific base class. This perfectly aligns with the goal of decoupling analysis engines from component implementations.
    *   **`@provides` Decorator:** This decorator implements the "Declarative Registration" mandate. It provides a clean, ergonomic API for plugin authors and eliminates an entire class of manual configuration errors by automating the discovery process.
*   **Implementation:**
    1.  **Create a new file:** `src/rfsim_core/components/base_enums.py`.
    2.  Move the `DCBehaviorType` enum from `components/base.py` into this new file. This is a crucial step to resolve a future circular import dependency between `capabilities.py` and `base.py`.
    3.  **Create a new file:** `src/rfsim_core/components/capabilities.py`.
    4.  Populate it with the following code. The docstrings are part of the contract and explicitly state the architectural requirements.

    ```python
    # src/rfsim_core/components/capabilities.py
    import logging
    from typing import Protocol, Type, Dict, Optional, List, Tuple, TypeVar, TYPE_CHECKING
    import numpy as np

    # These imports are essential to define the method signatures correctly.
    from ..units import Quantity
    from .base_enums import DCBehaviorType # Import from new, separated file.

    # Use TYPE_CHECKING to import ComponentBase only for type analysis,
    # preventing a circular import at runtime.
    if TYPE_CHECKING:
        from .base import ComponentBase

    logger = logging.getLogger(__name__)

    class ComponentCapability(Protocol):
        """
        A marker protocol for all component capabilities. Any class that provides
        a specific functionality to an analysis engine should conform to a
        protocol that inherits from this one.
        """
        pass

    # TCapability is a TypeVar bound to ComponentCapability. This allows for precise
    # type-hinting in `ComponentBase.get_capability`, ensuring that a request for
    # `IMnaContributor` is known by the type checker to return an `IMnaContributor`.
    TCapability = TypeVar("TCapability", bound=ComponentCapability)

    class IMnaContributor(ComponentCapability):
        """
        Defines the capability of a component to contribute to a linear,
        frequency-domain MNA system.

        ARCHITECTURAL CONTRACT:
        This method MUST be a vectorized operation. It accepts the full array of
        simulation frequencies and is expected to return the MNA stamp contributions
        for all frequencies in a single, efficient computation. This is critical for
        maintaining simulation performance. The simulation executive will call this
        method ONCE, before the per-frequency loop begins.
        """
        def get_mna_stamps(
            self,
            component: 'ComponentBase', # The component instance provides context.
            freq_hz_array: np.ndarray,
            all_evaluated_params: Dict[str, Quantity]
        ) -> List[Tuple[Quantity, List[str | int]]]:
            ...

    class IDcContributor(ComponentCapability):
        """
        Defines the capability of a component to contribute to a DC (F=0) analysis.
        The signature MUST match the data-passing requirements of the DCAnalyzer.
        """
        def get_dc_behavior(
            self,
            component: 'ComponentBase', # The component instance provides context.
            all_dc_params: Dict[str, Quantity]
        ) -> Tuple[DCBehaviorType, Optional[Quantity]]:
            ...

    def provides(capability_protocol: Type[ComponentCapability]):
        """
        A class decorator to register a class as an implementation for a capability.

        This decorator attaches a private attribute, `_implements_capability`, to the
        decorated class. The `ComponentBase.declare_capabilities` method will use this
        attribute for automatic discovery. This implements the 'Declarative Registration'
        mandate, making the API robust and easy to use for plugin authors.

        Args:
            capability_protocol: The capability Protocol (e.g., IMnaContributor)
                                 that this class implements.
        """
        def decorator(cls: Type) -> Type:
            if not issubclass(capability_protocol, ComponentCapability):
                 raise TypeError(
                    f"Decorator argument for @provides must be a ComponentCapability "
                    f"Protocol, but got {capability_protocol}."
                 )
            # Attach the metadata directly to the implementation class.
            cls._implements_capability = capability_protocol
            logger.debug(f"Class '{cls.__name__}' registered as providing capability '{capability_protocol.__name__}'.")
            return cls
        return decorator
    ```

##### **Task 2: Refactor `ComponentBase` to be a Capability Provider**

*   **Goal:** Modify the `ComponentBase` abstract class to remove the old, monolithic methods and implement the new, dynamic capability discovery and query system. This is the central architectural change of the phase.
*   **Justification:** Deleting the old abstract methods strictly enforces the new decoupled paradigm. The `get_capability` method provides the single, official query point, and its internal cache mitigates the performance cost of repeated lookups and instantiations. The automatic discovery in `declare_capabilities` fulfills the "Declarative and Robust Registration" mandate by correctly supporting inheritance via MRO inspection.
*   **Implementation:**
    1.  **Modify `src/rfsim_core/components/base.py`**.
    2.  Import `inspect`, and the new types from `capabilities.py` and `base_enums.py`.
    3.  **Delete** the abstract methods: `get_mna_stamps` and `get_dc_behavior`.
    4.  Add the new automatic `declare_capabilities` method and the `get_capability` method.

    ```python
    # src/rfsim_core/components/base.py
    import logging
    import inspect  # NEW IMPORT
    from abc import ABC, abstractmethod
    from typing import Dict, Any, List, Tuple, ClassVar, Optional, Type

    # ... other existing imports for units, parameters, parser ...
    # --- NEW IMPORTS ---
    from .capabilities import ComponentCapability, TCapability, IMnaContributor, IDcContributor
    from .base_enums import DCBehaviorType # From new file

    class ComponentBase(ABC):
        # ... existing properties like fqn, parameter_fqns ...

        def __init__(
            self,
            instance_id: str,
            parameter_manager: ParameterManager,
            parent_hierarchical_id: str,
            raw_ir_data: ParsedComponentData
        ):
            # ... existing initializations for id, pm, etc. ...
            self.ureg = ureg
            # This instance-level cache is a critical performance optimization.
            # It ensures that for a given component instance, each capability object
            # is created only ONCE on its first request. This amortizes the cost
            # of discovery and instantiation across the entire simulation.
            self._capability_cache: Dict[Type[ComponentCapability], ComponentCapability] = {}
            logger.debug(f"Initialized {type(self).__name__} '{self.fqn}'")

        # --- OLD METHODS (TO BE DELETED) ---
        # @abstractmethod
        # def get_mna_stamps(...) -> List[StampInfo]: ...
        # @abstractmethod
        # def get_dc_behavior(...) -> Tuple[DCBehaviorType, Optional[Quantity]]: ...

        # --- NEW METHODS (TO BE ADDED) ---

        @classmethod
        def declare_capabilities(cls) -> Dict[Type[ComponentCapability], Type]:
            """
            Automatically discovers and returns the capabilities map by robustly
            inspecting the class hierarchy (MRO).

            This method fulfills the 'Declarative and Robust Registration' mandate.
            It introspects the component class's full Method Resolution Order (MRO)
            to find nested classes decorated with `@provides`. This correctly handles
            capabilities defined in parent classes, making the plugin API robust,
            predictable, and intuitive for authors.
            """
            discovered_capabilities = {}
            # We iterate through the MRO to correctly handle inheritance. The MRO
            # is ordered from the class itself to its parents, so the first
            # implementation found for a given protocol is the most specific one.
            for base_class in cls.__mro__:
                # Use inspect.getmembers to find all members of the class.
                for _, member_obj in inspect.getmembers(base_class):
                    # Check for the magic attribute set by the @provides decorator.
                    if hasattr(member_obj, '_implements_capability'):
                        protocol = member_obj._implements_capability
                        # Only add it if we haven't already found a more specific one.
                        if protocol not in discovered_capabilities:
                            discovered_capabilities[protocol] = member_obj
            return discovered_capabilities

        def get_capability(self, capability_type: Type[TCapability]) -> Optional[TCapability]:
            """
            Queries the component instance for a specific capability.

            This is the sole, public-facing entry point for all analysis engines.
            It implements a lazy-loading and caching pattern:
            1. Checks the instance-level cache for an existing capability object.
            2. If not found, it calls the class-level discovery method.
            3. If declared, it instantiates the stateless capability implementation class.
            4. The new instance is cached for future requests and returned.
            """
            # 1. Check instance cache first for maximum performance.
            if capability_type in self._capability_cache:
                return self._capability_cache[capability_type]

            # 2. On cache miss, consult the class-level declaration via discovery.
            declared = type(self).declare_capabilities()
            impl_class = declared.get(capability_type)

            if impl_class:
                # 3. Instantiate the stateless capability object.
                instance = impl_class()
                
                # 4. Cache the singleton instance and return it.
                self._capability_cache[capability_type] = instance
                return instance

            # Return None if the component does not support this capability.
            return None

        # ... other methods like declare_parameters, declare_ports, is_structurally_open remain ...
    ```

##### **Task 3: Refactor Leaf Components (`R`, `L`, `C`)**

*   **Goal:** Modify the `Resistor`, `Capacitor`, and `Inductor` classes to conform to the new architecture, using nested classes for capability implementations.
*   **Justification:** This task realizes the "Cohesion of Implementation" mandate. By nesting the `MnaContributor` and `DcContributor` classes inside `Resistor`, all resistor-related logic becomes a single, self-contained, and easily discoverable unit, dramatically improving code readability and maintainability. The capability implementation classes are stateless and receive the component instance as context.
*   **Implementation:**
    1.  **Modify `src/rfsim_core/components/elements.py`**.
    2.  Use the `Resistor` class as the canonical example. The logic from the old `get_mna_stamps` and `get_dc_behavior` methods is moved, verbatim, into the respective nested capability classes.

    ```python
    # src/rfsim_core/components/elements.py
    # ... other imports for numpy, logging, etc. ...
    from .capabilities import IMnaContributor, IDcContributor, provides
    from .base import ComponentBase # For type hinting

    @register_component("Resistor")
    class Resistor(ComponentBase):
        # --- Capability Implementations are Nested Here ---

        @provides(IMnaContributor)
        class MnaContributor:
            """Stateless implementation of the MNA contribution capability for a Resistor."""
            def get_mna_stamps(
                self, component: 'Resistor', freq_hz_array: np.ndarray, all_evaluated_params: Dict[str, Quantity]
            ) -> List[Tuple[Quantity, List[str | int]]]:
                # This logic is moved VERBATIM from the old Resistor.get_mna_stamps method.
                # The component instance is now an explicit argument, used to get context like FQNs.
                param_fqn = component.parameter_fqns[0]
                r_qty = all_evaluated_params[param_fqn]
                
                # ... same logic as before ...
                if np.any(r_real_mag < 0):
                    # Use component.fqn for clear error reporting.
                    raise ComponentError(f"Resistance must be non-negative for {component.fqn}. Got a negative value.")
                # ... rest of the stamping logic ...
                return [(Quantity(stamp_mag, ureg.siemens), [PORT_1, PORT_2])]

        @provides(IDcContributor)
        class DcContributor:
            """Stateless implementation of the DC contribution capability for a Resistor."""
            def get_dc_behavior(
                self, component: 'Resistor', all_dc_params: Dict[str, Quantity]
            ) -> Tuple[DCBehaviorType, Optional[Quantity]]:
                # This logic is moved VERBATIM from the old Resistor.get_dc_behavior method.
                param_fqn = component.parameter_fqns[0]
                r_real_val = _extract_dc_real_scalar_value(all_dc_params, param_fqn, component.fqn)
                # ... rest of the DC behavior logic ...
                return (DCBehaviorType.ADMITTANCE, (1.0 / all_dc_params[param_fqn][0]).to(ureg.siemens))

        # --- Component's Own Declarations Follow ---
        @classmethod
        def declare_parameters(cls) -> Dict[str, str]:
            return {"resistance": "ohm"}
        
        # ... other methods like declare_ports, is_structurally_open ...

    # The same refactoring pattern MUST be applied to Capacitor and Inductor.
    ```

##### **Task 4: Refactor the Hierarchical Component (`SubcircuitInstance`)**

*   **Goal:** Prove the architecture's soundness by correctly refactoring `SubcircuitInstance`, the most complex component in the system.
*   **Justification:** This task demonstrates that the architecture can handle complex, proxy-like components. The capability methods correctly receive the `SubcircuitInstance` object and access its pre-computed cache to fulfill their contracts.
*   **Implementation:**
    1.  **Modify `src/rfsim_core/components/subcircuit.py`**.
    2.  Apply the same nested class pattern. The implementation of `get_mna_stamps` in the nested class will access the cache via `component.cached_y_parameters_ac`.

    ```python
    # src/rfsim_core/components/subcircuit.py
    # ... imports for logging, numpy, typing etc. ...
    from .capabilities import IMnaContributor, IDcContributor, provides
    from .base import ComponentBase # For type hinting

    @register_component("Subcircuit")
    class SubcircuitInstance(ComponentBase):

        @provides(IMnaContributor)
        class MnaContributor:
            """Provides the pre-computed, cached MNA stamp for the subcircuit."""
            def get_mna_stamps(
                self, component: 'SubcircuitInstance', freq_hz_array: np.ndarray, all_evaluated_params: Dict[str, Quantity]
            ) -> List[Tuple[Quantity, List[str | int]]]:
                # Access the cache on the component instance passed as context.
                assert (
                    component.cached_y_parameters_ac is not None
                ), f"FATAL: Subcircuit '{component.fqn}' AC cache was not populated."

                # The contract is to return the full, vectorized stamp matrix.
                # The simulation executive expects this.
                admittance_matrix_qty = Quantity(
                    component.cached_y_parameters_ac, component.ureg.siemens
                )
                return [(admittance_matrix_qty, component.sub_circuit_external_port_names_ordered)]

        @provides(IDcContributor)
        class DcContributor:
            """Provides the pre-computed, cached DC behavior for the subcircuit."""
            def get_dc_behavior(
                self, component: 'SubcircuitInstance', all_dc_params: Dict[str, Quantity]
            ) -> Tuple[DCBehaviorType, Optional[Quantity]]:
                assert (
                    component.cached_dc_analysis_results is not None
                ), f"FATAL: Subcircuit '{component.fqn}' DC cache was not populated."

                y_ports_dc_qty = component.cached_dc_analysis_results.get("Y_ports_dc")

                if isinstance(y_ports_dc_qty, Quantity):
                    return (DCBehaviorType.ADMITTANCE, y_ports_dc_qty)

                return (DCBehaviorType.OPEN_CIRCUIT, None)
                
        # The SubcircuitInstance's __init__, properties, and other methods remain as before.
    ```

##### **Task 5: Refactor Analysis Engines to Preserve Vectorized Execution (CRITICAL CORRECTION)**

*   **Goal:** Update the `_run_single_level_simulation` executive and `DCAnalyzer` to use the new `get_capability` query system, completing the decoupling **while strictly preserving the high-performance vectorized execution model.**
*   **Justification:** This task realizes the "payoff" of the new architecture and implements the critical performance fix identified in the review. The expensive, vectorized `get_mna_stamps` call is correctly placed in the simulation executive's **pre-computation step**, *before* the per-frequency loop. The `MnaAssembler` remains a lean, fast assembler that only deals with data slicing and placement, its responsibilities unchanged from Phase 8.
*   **Implementation:**
    1.  **Modify `src/rfsim_core/simulation/execution.py`:** Update the `_run_single_level_simulation` function's "Vectorized Pre-computation Step". The `MnaAssembler.assemble` method and its surrounding loop **require no changes** from their Phase 8 implementation.

        ```python
        # In src/rfsim_core/simulation/execution.py, inside _run_single_level_simulation

        # --- Vectorized Pre-computation Step (REVISED AND CORRECTED LOGIC) ---
        logger.debug(f"[{circuit.hierarchical_id}] Evaluating all parameters for the full frequency sweep...")
        all_evaluated_params = circuit.parameter_manager.evaluate_all(freq_array_hz)
        
        logger.debug(f"[{circuit.hierarchical_id}] Pre-computing all vectorized MNA stamps via capabilities...")
        all_stamps_vectorized: Dict[str, List[Tuple[Quantity, List[str | int]]]] = {}
        
        # Loop through effective components ONCE, before the frequency loop, to gather all stamps.
        for comp_fqn, sim_comp in assembler.effective_sim_components.items():
            # Query the component for the MNA contribution capability.
            mna_contributor = sim_comp.get_capability(IMnaContributor)
            
            if mna_contributor:
                try:
                    # Call the vectorized method ONCE. The signature is identical to the old way.
                    # The result is a list of stamps, where the Quantity inside is vectorized,
                    # e.g., with shape=(num_frequencies, num_ports, num_ports).
                    stamps = mna_contributor.get_mna_stamps(
                        sim_comp, freq_array_hz, all_evaluated_params
                    )
                    all_stamps_vectorized[comp_fqn] = stamps
                except Exception as e:
                    # Wrap any failure in a diagnosable, contextual error.
                    raise ComponentError(component_fqn=comp_fqn, details=f"Failed during vectorized MNA stamp computation: {e}") from e
            else:
                # Component does not contribute to MNA. The assembler will correctly
                # skip it as its FQN will not be in the all_stamps_vectorized dict.
                logger.debug(f"Component '{comp_fqn}' does not provide IMnaContributor capability. Skipping MNA contribution.")
                
        logger.debug(f"[{circuit.hierarchical_id}] All vectorized stamps pre-computed.")

        # --- Main Frequency Loop (Lean Assembly) ---
        # The rest of the function, including the call to assembler.assemble(idx, all_stamps_vectorized),
        # remains UNCHANGED from its Phase 8 implementation. This is the key to preserving performance.
        ```
    2.  **Modify `src/rfsim_core/analysis_tools.py`:** Update the `DCAnalyzer._resolve_and_collect_dc_behaviors` method to use the capability interface. This logic was correct in the original proposal and is preserved here for completeness.

        ```python
        # In src/rfsim_core/analysis_tools.py, inside DCAnalyzer._resolve_and_collect_dc_behaviors loop

        for comp_id, sim_comp in self.circuit.sim_components.items():
            try:
                # Query for the DC capability
                dc_contributor = sim_comp.get_capability(IDcContributor)
                if dc_contributor:
                    behavior_type, admittance_qty = dc_contributor.get_dc_behavior(sim_comp, all_dc_params)
                    dc_behaviors[comp_id] = (behavior_type, admittance_qty)
                else:
                    # If a component has no DC behavior, it's an open circuit by default.
                    # This is a safe and robust default for future non-electrical components.
                    dc_behaviors[comp_id] = (DCBehaviorType.OPEN_CIRCUIT, None)
            except (ComponentError, KeyError) as e:
                # ... existing error handling ...
        ```

##### **Task 6: Comprehensive Testing and Documentation**

*   **Goal:** Ensure the new architecture is fully tested, verified for performance, and documented for future developers and plugin authors.
*   **Implementation:**
    1.  **Unit Tests (`tests/components/test_capabilities.py`):**
        *   Test the `@provides` decorator: ensure it correctly attaches the `_implements_capability` attribute to a nested class.
        *   Test `ComponentBase.declare_capabilities`:
            *   Verify it correctly discovers decorated nested classes in a simple component.
            *   **Crucially, create a test with a parent component class (e.g., `TwoPortBase`) and a child component class (`Resistor` inheriting from it). Verify that a capability defined in the parent is correctly discovered for an instance of the child, proving the MRO-based discovery is robust.**
        *   Test `ComponentBase.get_capability`:
            *   Assert it returns a valid, non-None instance for a supported capability.
            *   Assert it returns `None` for an unsupported capability.
            *   Assert that it returns the *exact same object instance* on subsequent calls to prove the instance-level cache (`_capability_cache`) is working correctly.
    2.  **Integration Tests:** All existing circuit simulation tests (`tests/simulation/test_end_to_end.py`, etc.) **MUST** pass without modification. This is the primary regression test that proves the refactoring was behavior-preserving.
    3.  **Performance Verification (Non-Negotiable Deliverable):**
        *   **Implement a new performance benchmark test** using `pytest-benchmark`.
        *   Simulate a moderately complex circuit (e.g., a multi-stage amplifier with 10-20 components) across a wide frequency sweep (e.g., 1001 points).
        *   Run this benchmark on the codebase *before* and *after* the Phase 9 refactoring.
        *   **Assert that there is no significant performance regression.** This is the final gatekeeper that proves the vectorized execution model was successfully preserved.
    4.  **Documentation (User and Developer):**
        *   Update the developer documentation, especially the **"Creating a Custom Component Plugin"** guide, to reflect the new, mandatory patterns.
        *   Create a new architectural document in the project's `docs/` folder: **"The Capability-Based Component Model"**. This document must explain:
            *   The strategic motivation for the architecture (extensibility for noise, HB, etc.).
            *   The role of `typing.Protocol` for achieving decoupling.
            *   The required use of the `@provides` decorator for declarative registration.
            *   The mandatory nested class pattern for realizing the "Cohesion of Implementation" mandate.
            *   The stateless nature of capability implementation classes and the `component` argument pattern used to pass context.
            *   The critical contract for performance-sensitive capabilities like `IMnaContributor` to be **fully vectorized** and the role of the simulation executive in calling them.
        *   Update all relevant docstrings in `base.py`, `capabilities.py`, `elements.py`, and `execution.py` to reflect the new design and its justifications.

### **Phase 10: The Simulation Services Architecture (Definitive & Final Plan)**

#### **1. Architectural Mandate: A Professional-Grade Foundation for a Verifiable Simulator**

**Topic:** This phase will rectify the final major architectural flaws in the simulation workflow by introducing a clean, professional, service-oriented architecture. This design is non-negotiable and reinforces the project's foundational principles of **Explicit Contracts** and **Correctness by Construction**.

**Strategic Justification (An Introduction for All Programmers):** The long-term success and reliability of a software project are dictated by the quality of its architecture. A poor architecture leads to bugs that are difficult to find, performance that is hard to predict, and features that are painful to add. The current system, while functional, contains deep architectural flaws that prevent it from being truly robust, testable, and extensible. This phase is a deliberate and strategic investment to fix these fundamental issues now, before they become hopelessly entangled in more complex features like noise or transient analysis.

The three critical deficiencies we will eliminate are:

1.  **The Anti-Pattern of Hidden Global State:** The `TopologyAnalyzer` currently uses a `static` (class-level) variable to cache its results. This is a dangerous and unprofessional practice known as *hidden global state*. It means that the result of one simulation can be silently affected by a completely different simulation that was run previously in the same process. This makes the software unpredictable, nightmarishly difficult to debug, and impossible to verify. We will destroy all hidden global state to ensure our simulations are **deterministic and reliable**.

2.  **The Inefficiency and Inconsistency of Unmanaged Analysis:** The `DCAnalyzer` performs no caching at all, forcing it to re-calculate results for identical subcircuits, which is a major performance bottleneck in hierarchical designs. The `TopologyAnalyzer` uses its own separate, hidden caching mechanism. This inconsistency makes the system hard to understand and maintain. A professional system demands a **unified, predictable, and efficient approach** to all major computations.

3.  **The Obscurity of Decentralized Logic:** The main simulation control flow is currently scattered across several free-standing functions in `simulation/execution.py`. This procedural style makes it difficult to follow the flow of data and control. It creates fragile code that is hard to test in isolation and resistant to change.

**The Solution (The Three Architectural Pillars):** This plan establishes the definitive pattern for all future simulation and analysis capabilities. It is built upon three core pillars that directly address the deficiencies above. Every task in this phase serves one or more of these pillars.

1.  **Centralized, Immutable State (`SimulationContext`):** We will introduce a single, declarative, type-safe data container that holds the complete, unchangeable state for a single simulation run. This object is the **"what"** of the simulation—the unambiguous source of truth for all inputs (the circuit, the frequencies) and shared resources (the cache). By making this object *immutable* (via `frozen=True`), we guarantee that a simulation's initial conditions cannot be accidentally changed during execution, which is a powerful technique for ensuring **Correctness by Construction**.

2.  **Stateless, Service-Oriented Logic (`SimulationEngine`):** We will create a class that contains all the logic for orchestrating a simulation but holds no state of its own. This object is the **"how"** of the simulation—it operates *on* a `SimulationContext` but does not *own* any data. This creates a perfect separation of concerns, making the simulation process transparent, deterministic, and easy to test in isolation.

3.  **Unified, Cache-Aware Services (Dependency Injection):** We will introduce a centralized `SimulationCache` service whose lifetime is explicitly managed. All major analysis tools (`DCAnalyzer`, `TopologyAnalyzer`) will be refactored into cache-aware services that are *given* this cache when they are created. This technique, called **Dependency Injection**, eradicates all hidden state, ensures uniform and correct caching behavior, and establishes a clear, professional blueprint for adding future analysis services (e.g., a Noise Analyzer).

This architecture is not merely a refactoring; it is the establishment of the definitive, professional-grade pattern for a reliable and extensible simulation core.

---

### **2. Detailed and In-Depth Implementation Plan**

This plan is broken down into sequential, verifiable tasks. Each task includes a clear goal, a rigorous justification for its necessity, and a detailed implementation specification.

#### **Task 0: Establish Performance Baseline (Non-Negotiable Prerequisite)**

*   **Goal:** Before any code is refactored, create a definitive, quantitative performance baseline using the existing, unmodified Phase 9 codebase.
*   **Rigorous Justification:** Professional engineering is evidence-based. It is impossible to verify that a major architectural refactoring has not introduced a performance regression without first measuring the performance *before* the changes. A benchmark created *after* the fact is useless for this purpose. This task establishes the immutable "before" state against which the final "after" state will be judged. It is the final gatekeeper that proves the critical high-performance characteristics of the Phase 9 vectorized architecture are preserved through this refactoring. It is a mandatory display of professional discipline.
*   **Detailed Implementation Steps:**
    1.  Create a new directory for benchmarks if it doesn't exist: `tests/benchmarks/`. Add a blank `__init__.py` file to make it a package.
    2.  Create a new test file: `tests/benchmarks/test_performance.py`.
    3.  Ensure a moderately complex hierarchical netlist exists for the benchmark (e.g., `tests/netlists/benchmark_filter.yaml`). It **MUST** be at least 2-3 levels deep and contain 15-20 total R/L/C components to correctly exercise the hierarchical logic this phase will refactor.
    4.  Using the `pytest-benchmark` library, implement the benchmark test exactly as follows to create a repeatable standard:

        ```python
        # tests/benchmarks/test_performance.py
        import pytest
        from pathlib import Path
        import numpy as np

        from rfsim_core import NetlistParser, CircuitBuilder, run_sweep, Circuit

        # Path to a netlist that defines a hierarchical circuit with subcircuits.
        BENCHMARK_NETLIST_PATH = Path(__file__).parent.parent / "netlists/benchmark_filter.yaml"

        @pytest.fixture(scope="session")
        def benchmark_circuit() -> Circuit:
            """A session-scoped fixture to parse and build the circuit only once per test session."""
            parser = NetlistParser()
            builder = CircuitBuilder()
            parsed_tree = parser.parse_to_circuit_tree(BENCHMARK_NETLIST_PATH)
            sim_circuit = builder.build_simulation_model(parsed_tree)
            return sim_circuit

        def test_hierarchical_sweep_performance(benchmark, benchmark_circuit: Circuit):
            """Benchmark the end-to-end performance of a hierarchical sweep using the Phase 9 API."""
            freqs = np.linspace(1e9, 10e9, 1001) # 1001 points from 1 GHz to 10 GHz
            
            # The benchmark fixture will run this function multiple times to get a stable measurement.
            def run():
                _freqs, _y_mats, _dc_res = run_sweep(benchmark_circuit, freqs)

            benchmark(run)
        ```
    5.  Execute this test against the **unmodified Phase 9 codebase** and save the resulting timing data. This is now the official performance baseline against which Task 5 will be measured.

#### **Task 1: Formalize Analysis Results and Establish the Cache Infrastructure**

*   **Goal:** Create the foundational data structures and services that enable the new architecture. We will define formal, type-safe "Result" objects for each major analysis, create the centralized `SimulationCache` service, and implement a `CacheKeyFactory` to ensure consistent, correct key generation.
*   **Rigorous Justification:** The "Explicit Contracts" mandate forbids passing raw, unstructured dictionaries or tuples between major system components. Raw data structures have no type safety, their keys are "magic strings" (string literals with implicit meaning), and their structure is fragile and unmaintainable. By defining formal `@dataclass(frozen=True)` objects for analysis results, we create a non-negotiable, self-documenting contract enforced by the type system. The `frozen=True` attribute is critical as it guarantees that a result, once computed, cannot be accidentally modified, thus ensuring the integrity of our cached data. Centralizing the complex logic for cache key generation into a single `CacheKeyFactory` eradicates duplicated logic and ensures correctness and consistency across the entire system.
*   **Detailed Implementation Steps:**
    *   **1.1. Create Formal Result Dataclasses and New Package Structure:**
        1.  Create a new package directory: `src/rfsim_core/analysis/`. Add a blank `__init__.py` file to it.
        2.  Create a new file: `src/rfsim_core/analysis/results.py`. This file will contain the formal result objects.

        ```python
        # src/rfsim_core/analysis/results.py
        from dataclasses import dataclass
        from typing import Dict, Any, Optional, List, Tuple, Set

        import numpy as np
        import networkx as nx

        from ..units import Quantity

        @dataclass(frozen=True)
        class DCAnalysisResults:
            """
            The formal, type-safe result of a DC analysis for a single circuit level.
            This object is the explicit contract between the DCAnalyzer and its consumers.
            It is immutable (frozen) to ensure correctness after creation.

            ARCHITECTURAL REFINEMENT: This dataclass is designed to be a fully
            self-contained record. The inclusion of `ground_supernode_name` ensures
            that consumers of this result do not need to refer back to the DCAnalyzer
            instance that created it, achieving complete decoupling.
            """
            y_ports_dc: Optional[Quantity]
            dc_port_names_ordered: List[str]
            dc_port_mapping: Dict[str, Optional[int]]
            dc_supernode_mapping: Dict[str, str]
            ground_supernode_name: Optional[str] # REFINEMENT: Added for full decoupling.

        @dataclass(frozen=True)
        class TopologyAnalysisResults:
            """
            The formal, type-safe result of a topological analysis for a single circuit level.
            This object is the explicit contract between the TopologyAnalyzer and its consumers.
            It is immutable (frozen) to ensure correctness after creation.
            """
            structurally_open_components: Set[str]
            ac_graph: nx.Graph
            active_nets: Set[str]
            external_port_connectivity: List[Tuple[str, str]]
        ```

    *   **1.2. Implement the `SimulationCache` and `CacheKeyFactory`:**
        1.  Create a new package directory: `src/rfsim_core/cache/`. Add a blank `__init__.py` file to it.
        2.  **Create the `SimulationCache` service:** Create a new file `src/rfsim_core/cache/service.py`.

        ```python
        # src/rfsim_core/cache/service.py
        import logging
        from typing import Dict, Any, Tuple

        logger = logging.getLogger(__name__)

        class SimulationCache:
            """
            A centralized, multi-scope caching service for a simulation run. It manages two
            distinct cache scopes:
            - 'run': An instance-level cache whose lifetime is tied to this specific
                     SimulationCache object. It is used for caching results that are only
                     valid within a single, top-level `run_sweep` call (e.g., subcircuit sims).
            - 'process': A class-level (static) cache that persists across multiple
                         `run_sweep` calls within the same Python process. It is used for
                         caching results that are guaranteed to be identical for a given
                         set of inputs, regardless of the run context (e.g., topology analysis).
            """
            _process_cache: Dict[Tuple, Any] = {}

            def __init__(self):
                self._run_cache: Dict[Tuple, Any] = {}
                self.clear_stats()
                logger.debug("SimulationCache instance created.")

            def get(self, key: Tuple, scope: str = 'run') -> Any:
                """Retrieves an item from the specified cache scope."""
                cache = self._get_cache_for_scope(scope)
                if key in cache:
                    self._stats[scope]['hits'] += 1
                    logger.debug(f"Cache HIT in '{scope}' scope for key: {str(key)[:100]}...")
                    return cache[key]
                self._stats[scope]['misses'] += 1
                logger.debug(f"Cache MISS in '{scope}' scope for key: {str(key)[:100]}...")
                return None

            def put(self, key: Tuple, value: Any, scope: str = 'run'):
                """Stores an item in the specified cache scope."""
                self._get_cache_for_scope(scope)[key] = value

            def _get_cache_for_scope(self, scope: str) -> Dict[Tuple, Any]:
                if scope == 'run': return self._run_cache
                if scope == 'process': return self.__class__._process_cache
                raise ValueError(f"Invalid cache scope '{scope}'. Must be 'run' or 'process'.")

            def get_stats(self) -> Dict[str, Dict[str, int]]:
                """Returns a copy of the cache hit/miss statistics."""
                return self._stats.copy()

            def clear_stats(self):
                """Resets the hit/miss statistics for this instance."""
                self._stats = {'run': {'hits': 0, 'misses': 0}, 'process': {'hits': 0, 'misses': 0}}

            @classmethod
            def clear_process_cache(cls):
                """A class method to explicitly clear the persistent process-level cache."""
                cls._process_cache.clear()
                logger.info("Cleared the persistent process-level cache.")
        ```
        3.  **Create the `CacheKeyFactory` with Mandatory Safety Fix:** Create `src/rfsim_core/cache/keys.py`. The logic for these functions is **MOVED** from its previous locations, not reinvented.

        ```python
        # src/rfsim_core/cache/keys.py
        import numpy as np
        from typing import Tuple

        from ..components.subcircuit import SubcircuitInstance
        from ..data_structures import Circuit
        from ..parameters import ParameterManager, ParameterError

        def create_subcircuit_sim_key(
            sub_inst: SubcircuitInstance, freq_array_hz: np.ndarray, global_pm: ParameterManager
        ) -> Tuple:
            """
            Creates the definitive cache key for a single-level subcircuit simulation result.
            This logic is moved from Phase 9's simulation/execution.py and is now centralized.
            """
            def_path_str = str(sub_inst.sub_circuit_object.source_file_path)
            overrides = sub_inst.raw_ir_data.raw_parameter_overrides
            canonical_overrides = tuple(sorted(
                (k, str(sorted(v.items()) if isinstance(v, dict) else v))
                for k, v in overrides.items()
            ))
            fqns_in_sub = {p.fqn for p in sub_inst.sub_circuit_object.parameter_manager.get_all_fqn_definitions()}
            const_ext, freq_ext = global_pm.get_external_dependencies_of_scope(fqns_in_sub)
            const_vals = tuple(sorted((fqn, f"{global_pm.get_constant_value(fqn):~P}") for fqn in const_ext))
            freq_defs = tuple(sorted((p.fqn, p.raw_value_or_expression_str, p.declared_dimension_str) for fqn in freq_ext if (p := global_pm.get_parameter_definition(fqn))))
            ext_context = (const_vals, freq_defs)
            freqs = tuple(np.sort(np.unique(freq_array_hz)))
            return ("subcircuit_sim", def_path_str, canonical_overrides, ext_context, freqs)

        def create_topology_key(circuit: Circuit) -> Tuple:
            """
            Creates the definitive cache key for a topology analysis result.
            This logic is moved from Phase 9's analysis_tools.py and is now centralized.
            The key is sensitive to the exact value of all constant parameters in scope.
            """
            source_path = str(circuit.source_file_path)
            const_params = []
            for p_def in circuit.parameter_manager.get_all_fqn_definitions():
                if p_def.owner_fqn.startswith(circuit.hierarchical_id) and circuit.parameter_manager.is_constant(p_def.fqn):
                    # MANDATORY SAFETY FIX: The try/except block is REMOVED.
                    # A failure to resolve a constant parameter during key generation MUST be a
                    # hard error, not silently ignored, to ensure Correctness by Construction.
                    # The top-level error handler will catch this and report it correctly.
                    val = circuit.parameter_manager.get_constant_value(p_def.fqn)
                    const_params.append((p_def.fqn, f"{val:~P}"))
            return ("topology", source_path, tuple(sorted(const_params)))

        def create_dc_analysis_key(circuit: Circuit) -> Tuple:
            """
            Creates the definitive cache key for a DC analysis result.

            RIGOROUS JUSTIFICATION: A DC analysis is dependent on the precise numerical value
            of *every* constant parameter that can influence DC behavior (e.g., resistance,
            or the DC representation of any component). A key based only on which components
            are shorts/opens is dangerously insufficient. The most robust and correct cache key
            must therefore be sensitive to changes in *any* of these constant values. The
            existing `create_topology_key` function already generates a key based on a
            canonical representation of all constant parameter FQNs and their exact values
            within a circuit's scope. By leveraging this existing, robust key generation
            logic and adding a unique 'dc_analysis' namespace prefix, we ensure correctness,
            prevent key collisions, and adhere to the DRY (Don't Repeat Yourself) principle.
            """
            return ("dc_analysis",) + create_topology_key(circuit)[1:]
        ```
        4.  Create `src/rfsim_core/cache/__init__.py`.
        ```python
        # src/rfsim_core/cache/__init__.py
        from .service import SimulationCache
        from .keys import create_dc_analysis_key, create_subcircuit_sim_key, create_topology_key
        
        __all__ = [
            "SimulationCache",
            "create_dc_analysis_key",
            "create_subcircuit_sim_key",
            "create_topology_key",
        ]
        ```

    *   **1.3. Enforce the New Result Contract in `SubcircuitInstance` (CRITICAL CORRECTION):**
        1.  Open `src/rfsim_core/components/subcircuit.py`.
        2.  Add the new import at the top of the file to bring the formal result dataclass into scope:
            ```python
            if TYPE_CHECKING:
                # Import the NEW formal result object.
                from ..analysis.results import DCAnalysisResults
            ```
        3.  In the `SubcircuitInstance.__init__` method, **change the type hint** for the cache attribute to use the new explicit contract. This is a non-negotiable change to uphold the "Explicit Contracts" mandate.
            ```python
            # In class SubcircuitInstance, __init__ method:
            # CHANGE THIS LINE:
            # self.cached_dc_analysis_results: Optional[Dict[str, Any]] = None
            # TO THIS:
            self.cached_dc_analysis_results: Optional["DCAnalysisResults"] = None
            ```
        4.  In the nested `DcContributor.get_dc_behavior` method, **change how the DC Y-matrix is accessed** to use the new explicit, type-safe contract. This change eliminates the fragile "magic string" lookup.
            ```python
            # In SubcircuitInstance.DcContributor.get_dc_behavior:
            def get_dc_behavior(self, component: "SubcircuitInstance", ...) -> ...:
                assert component.cached_dc_analysis_results is not None, "..."

                # CHANGE THIS LINE:
                # y_ports_dc_qty = component.cached_dc_analysis_results.get("Y_ports_dc")
                # TO THIS, which is type-safe and contractually explicit:
                y_ports_dc_qty = component.cached_dc_analysis_results.y_ports_dc

                if isinstance(y_ports_dc_qty, Quantity):
                    # ...
            ```

#### **Task 2: Refactor Analysis Tools into Cache-Aware Services**

*   **Goal:** Eradicate all hidden state from `DCAnalyzer` and `TopologyAnalyzer` and transform them into pure, testable services that use the centralized `SimulationCache` via dependency injection.
*   **Rigorous Justification:** The presence of a static `_persistent_topology_cache` in `TopologyAnalyzer` was a severe architectural flaw, a classic example of hidden global state. By refactoring both tools to accept a `SimulationCache` object in their constructor (`__init__`), we make their dependency on the caching service explicit. This **Dependency Injection** pattern is fundamental to creating loosely-coupled, highly-testable, and maintainable systems. A class is *given* the tools it needs (like a cache) rather than creating or knowing about them globally. This also unifies the caching strategy for all analysis tools, fulfilling a key goal of this phase.
*   **Detailed Implementation Steps:**
    *   **2.1. Relocate and Refactor `analysis_tools.py`:**
        1.  **Move** the file `src/rfsim_core/analysis_tools.py` to `src/rfsim_core/analysis/tools.py`.
        2.  Add the new required imports to the top of the new `tools.py` file:
            ```python
            from ..cache.service import SimulationCache
            from ..cache.keys import create_topology_key, create_dc_analysis_key
            from .results import TopologyAnalysisResults, DCAnalysisResults
            ```
        3.  Create an `__init__.py` in the new package to export the public interfaces:
            ```python
            # src/rfsim_core/analysis/__init__.py
            from .results import DCAnalysisResults, TopologyAnalysisResults
            from .tools import DCAnalyzer, TopologyAnalyzer
            
            __all__ = ["DCAnalysisResults", "TopologyAnalysisResults", "DCAnalyzer", "TopologyAnalyzer"]
            ```
        4.  Update all imports throughout the codebase that reference the old `analysis_tools` path (e.g., in `simulation/execution.py`) to use the new `rfsim_core.analysis` path.

    *   **2.2. Refactor `TopologyAnalyzer`:**
        *   **DELETE** the static `_persistent_topology_cache: Dict` attribute from the class definition.
        *   **DELETE** the private `_get_cache_key` method. It is now centralized in `cache/keys.py`.
        *   Modify the `__init__` method signature to accept and store the cache via dependency injection:
            ```python
            # In class TopologyAnalyzer, inside src/rfsim_core/analysis/tools.py
            def __init__(self, circuit: Circuit, cache: SimulationCache):
                if not isinstance(circuit, Circuit) or not circuit.parameter_manager:
                    raise TypeError("TopologyAnalyzer requires a valid, simulation-ready Circuit object.")
                
                self.circuit: Circuit = circuit
                self.parameter_manager: ParameterManager = circuit.parameter_manager
                self._analysis_results: Optional[TopologyAnalysisResults] = None
                self.cache: SimulationCache = cache # Dependency Injection
                logger.debug(f"TopologyAnalyzer initialized for circuit '{circuit.hierarchical_id}'.")
            ```
        *   **REWRITE** the `analyze` method to implement the "get-from-cache-or-compute" pattern. The return type **MUST** change from `Dict` to `TopologyAnalysisResults`.

            ```python
            # In class TopologyAnalyzer
            def analyze(self) -> TopologyAnalysisResults:
                if self._analysis_results is not None:
                    return self._analysis_results

                cache_key = create_topology_key(self.circuit)
                cached_results = self.cache.get(key=cache_key, scope='process')
                if cached_results:
                    self._analysis_results = cached_results
                    return cached_results

                logger.debug(f"Cache MISS for topology of '{self.circuit.name}'. Performing full analysis.")
                
                open_comps = self._resolve_and_identify_structurally_open_components()
                ac_graph = self._build_ac_graph(open_comps)
                active_nets = self._compute_active_nets(ac_graph)
                port_connectivity = self._compute_external_port_connectivity(ac_graph)
                
                results = TopologyAnalysisResults(
                    structurally_open_components=open_comps,
                    ac_graph=ac_graph,
                    active_nets=active_nets,
                    external_port_connectivity=port_connectivity,
                )

                self.cache.put(key=cache_key, value=results, scope='process')
                self._analysis_results = results
                return results
            ```

    *   **2.3. Refactor `DCAnalyzer` (The Critical Fix):**
        *   Apply the **exact same refactoring pattern** to `DCAnalyzer`.
        *   Modify its `__init__` to accept and store the `SimulationCache` via dependency injection.
        *   Rewrite its `analyze` method to implement the "get-from-cache-or-compute" pattern, using `create_dc_analysis_key` and the `'process'` scope. Its return type **MUST** change from `Dict[str, Any]` to `DCAnalysisResults`.
        *   Inside the "compute" block (after a cache miss), at the very end, package all results into the formal `DCAnalysisResults` object, **including the `ground_supernode_name`**, before storing it in the cache and returning it.
        *   **Ensure all `raise DCAnalysisError(...)` statements are preserved** to maintain the actionable diagnostics contract.

            ```python
            # In class DCAnalyzer
            def __init__(self, circuit: Circuit, cache: SimulationCache):
                # ... (similar initialization as TopologyAnalyzer)
                self.cache: SimulationCache = cache # Dependency Injection
            
            def analyze(self) -> DCAnalysisResults:
                cache_key = create_dc_analysis_key(self.circuit)
                cached_results = self.cache.get(key=cache_key, scope='process')
                if cached_results:
                    return cached_results

                logger.info(f"Cache MISS. Starting rigorous DC analysis for circuit '{self.circuit.hierarchical_id}'...")
                
                # ALL EXISTING DC ANALYSIS LOGIC (from _resolve_and_collect... to _build_dc_port_mapping)
                # is executed here, verbatim, after a cache miss.
                
                dc_behaviors = self._resolve_and_collect_dc_behaviors()
                self._build_dc_supernode_graph(dc_behaviors)
                # ... etc ...
                y_ports_dc_qty = self._calculate_dc_y_parameters(y_dc_super_full)
                dc_port_mapping = self._build_dc_port_mapping()
                
                # Create the formal, self-contained result object.
                results = DCAnalysisResults(
                    y_ports_dc=y_ports_dc_qty,
                    dc_port_names_ordered=self._dc_port_names_ordered,
                    dc_port_mapping=dc_port_mapping,
                    dc_supernode_mapping=self._supernode_map.copy(),
                    ground_supernode_name=self._ground_supernode_representative_name # The critical fix.
                )
                
                self.cache.put(key=cache_key, value=results, scope='process')
                return results
            ```

#### **Task 3: Implement the Engine by Relocating and Adapting Existing Logic**

*   **Goal:** Create the `SimulationContext` and `SimulationEngine` classes, establishing the clear separation of state and logic. All simulation control logic will be **moved** from `simulation/execution.py` into the `SimulationEngine`.
*   **Rigorous Justification:** The primary goal here is to centralize control flow into a testable, stateless service, fulfilling the architectural pillar. The high-performance vectorized logic from Phase 9 is already correct. This task is therefore a pure architectural refactoring: we are **relocating** existing, correct logic, not reinventing it. This simplifies the task and focuses it on improving the system's structure, testability, and clarity, not its core algorithms.
*   **Detailed Implementation Steps:**
    *   **3.1. Create the `SimulationContext` Data Class and a New Result Contract:**
        *   Create `src/rfsim_core/simulation/context.py` and implement the `SimulationContext` `frozen=True` dataclass exactly as follows:
        ```python
        # src/rfsim_core/simulation/context.py
        from dataclasses import dataclass
        import numpy as np

        from ..data_structures import Circuit
        from ..cache.service import SimulationCache

        @dataclass(frozen=True)
        class SimulationContext:
            """
            An immutable container for the complete state of a single simulation run.
            This object is the "what" of the simulation, passed to the SimulationEngine.
            Its immutability guarantees that a simulation's initial conditions cannot be
            altered mid-execution, ensuring Correctness by Construction.
            """
            top_level_circuit: Circuit
            freq_array_hz: np.ndarray
            cache: SimulationCache
        ```
        *   Create `src/rfsim_core/simulation/results.py` and define the contract for a cached subcircuit simulation. This replaces the implicit tuple contract.
        ```python
        # src/rfsim_core/simulation/results.py
        from dataclasses import dataclass
        from typing import Optional
        import numpy as np
        
        from ..analysis.results import DCAnalysisResults

        @dataclass(frozen=True)
        class SubcircuitSimResults:
            """The formal, cached result of a single-level subcircuit simulation."""
            y_parameters: np.ndarray
            dc_results: Optional[DCAnalysisResults]

        # This class will be expanded in Task 4
        @dataclass(frozen=True)
        class SimulationResult:
            """The final, user-facing result of a top-level simulation sweep."""
            ...
        ```

    *   **3.2. Implement the `SimulationEngine` by Moving Existing Logic:**
        *   Create `src/rfsim_core/simulation/engine.py`.
        *   Implement the `SimulationEngine` class. **MOVE**, do not rewrite, the logic from the free-standing functions in the old `execution.py` into methods of this class, adapting it to use the new explicit result contracts.

        ```python
        # src/rfsim_core/simulation/engine.py
        import logging
        import numpy as np
        from typing import List, Optional, Tuple

        from ..data_structures import Circuit
        from ..components.subcircuit import SubcircuitInstance
        from ..simulation.exceptions import (
            MnaInputError,
            ComponentError,
            SingularMatrixError,
            SingleLevelSimulationFailure,
        )
        from ..analysis.exceptions import DCAnalysisError
        from ..parameters import ParameterError
        from ..units import ureg
        from ..constants import LARGE_ADMITTANCE_SIEMENS

        from .context import SimulationContext
        from .results import SubcircuitSimResults # Import the new explicit contract
        from ..analysis import DCAnalysisResults, DCAnalyzer, TopologyAnalyzer # The new services
        from ..cache import create_subcircuit_sim_key

        logger = logging.getLogger(__name__)

        class SimulationEngine:
            """
            A stateless service that orchestrates the simulation process.
            This object contains the imperative logic (the "how") and operates on a
            given SimulationContext (the "what"). It owns no state itself.
            """
            def __init__(self, context: SimulationContext):
                self.context: SimulationContext = context
                self.circuit: Circuit = context.top_level_circuit
                self.freq_array_hz: np.ndarray = context.freq_array_hz
                self.cache: SimulationCache = context.cache # Dependency Injection
                self.global_pm = self.circuit.parameter_manager
                logger.debug(f"SimulationEngine initialized for '{self.circuit.name}'.")

            def execute_sweep(self) -> Tuple[np.ndarray, Optional[DCAnalysisResults]]:
                """The main entry point for the engine. Orchestrates the hierarchical sweep."""
                self._populate_subcircuit_caches_recursive(self.circuit)
                y_mats, dc_res = self._run_single_level_simulation(self.circuit)
                return y_mats, dc_res

            def _populate_subcircuit_caches_recursive(self, circuit_node: Circuit):
                """MOVED from execution.py. Recursively simulates subcircuits and populates cache."""
                for sim_comp in circuit_node.sim_components.values():
                    if isinstance(sim_comp, SubcircuitInstance):
                        self._populate_subcircuit_caches_recursive(sim_comp.sub_circuit_object)
                        cache_key = create_subcircuit_sim_key(sim_comp, self.freq_array_hz, self.global_pm)
                        
                        cached_results: Optional[SubcircuitSimResults] = self.cache.get(key=cache_key, scope='run')

                        if cached_results:
                            results_to_use = cached_results
                        else:
                            y_mats, dc_res = self._run_single_level_simulation(sim_comp.sub_circuit_object)
                            results_to_use = SubcircuitSimResults(y_parameters=y_mats, dc_results=dc_res)
                            self.cache.put(key=cache_key, value=results_to_use, scope='run')

                        sim_comp.cached_y_parameters_ac = results_to_use.y_parameters
                        sim_comp.cached_dc_analysis_results = results_to_use.dc_results
            
            def _run_single_level_simulation(self, circuit: Circuit) -> Tuple[np.ndarray, Optional[DCAnalysisResults]]:
                """MOVED and ADAPTED from execution.py. Runs simulation for a single circuit level."""
                try:
                    # Instantiate services using Dependency Injection
                    dc_analyzer = DCAnalyzer(circuit, self.cache)
                    dc_analysis_results = dc_analyzer.analyze()
            
                    topology_analyzer = TopologyAnalyzer(circuit, self.cache)
                    topo_results = topology_analyzer.analyze()
                    active_nets_for_ac = topo_results.active_nets
                    
                    # (The rest of the logic from the old function is moved here verbatim,
                    # including all MnaInputError checks, assembler instantiation, pre-computation loop,
                    # and the main frequency loop for assembly and solving. These are correct.)
                    # ...
                    # The call to _map_dc_y_to_ac_ports is updated to pass the results object.
                    y_matrices[idx] = self._map_dc_y_to_ac_ports(dc_analysis_results, ac_port_names_ordered)
                    # ...
                    return (y_matrices, dc_analysis_results)
                
                except (DCAnalysisError, MnaInputError, ComponentError, SingularMatrixError, ParameterError) as e:
                    # Wrap in a diagnosable, contextual error
                    raise SingleLevelSimulationFailure(
                        circuit_fqn=circuit.hierarchical_id,
                        circuit_source_path=circuit.source_file_path,
                        original_error=e,
                    ) from e

            def _map_dc_y_to_ac_ports(self, dc_results: DCAnalysisResults, ac_port_names: List[str]) -> np.ndarray:
                """MOVED from execution.py and REFINED to use the self-contained results object."""
                # This method now has no dependency on the DCAnalyzer instance.
                num_ac_ports = len(ac_port_names)
                y_dc_qty = dc_results.y_ports_dc
                dc_port_map = dc_results.dc_port_mapping
                y_mapped = np.zeros((num_ac_ports, num_ac_ports), dtype=np.complex128)
                
                if y_dc_qty is None: return y_mapped

                y_dc_mag = y_dc_qty.to(ureg.siemens).magnitude
                ac_to_dc_idx_map = {ac_idx: dc_port_map.get(ac_name) for ac_idx, ac_name in enumerate(ac_port_names)}

                for r_ac, r_dc in ac_to_dc_idx_map.items():
                    if r_dc is None: continue
                    for c_ac, c_dc in ac_to_dc_idx_map.items():
                        if c_dc is None: continue
                        y_mapped[r_ac, c_ac] = y_dc_mag[r_dc, c_dc]

                for ac_idx, ac_name in enumerate(ac_port_names):
                    if ac_to_dc_idx_map.get(ac_idx) is None:
                        # Use the self-contained results object for the check.
                        srep = dc_results.dc_supernode_mapping.get(ac_name)
                        if srep and srep == dc_results.ground_supernode_name:
                            y_mapped[ac_idx, ac_idx] = LARGE_ADMITTANCE_SIEMENS
                return y_mapped
        ```

#### **Task 4: Finalize the Public API and Result Contract**

*   **Goal:** Provide a clean, powerful, and user-friendly public function that encapsulates the entire new architecture and returns a type-safe, explicit result object.
*   **Rigorous Justification:** Internal complexity should be hidden from the typical user. The `run_sweep` function acts as a **Facade**, providing a simple entry point that handles all the setup of contexts, engines, and caches. A programmer using the library should not need to know about `SimulationEngine` or `SimulationContext` for a standard run. Its return value **MUST** be an explicit contract, not a raw tuple. A `SimulationResult` dataclass makes the output self-documenting and prevents user errors. The optional `cache` argument exposes the power of the new architecture for advanced use cases (e.g., re-running a sweep with a modified parameter) without complicating the simple path.
*   **Detailed Implementation Steps:**
    *   **4.1. Define the Final Result Contract:**
        *   Finalize `src/rfsim_core/simulation/results.py`.
        ```python
        # src/rfsim_core/simulation/results.py
        # ... (SubcircuitSimResults is already here from Task 3)
        @dataclass(frozen=True)
        class SimulationResult:
            """
            The final, user-facing result of a simulation sweep.
            This object provides an explicit, type-safe contract for the simulation output.
            """
            frequencies_hz: np.ndarray
            y_parameters: np.ndarray
            top_level_dc_results: Optional[DCAnalysisResults]
        ```
    *   **4.2. Refactor `simulation/execution.py` to be a Thin API Wrapper:**
        *   This file is now drastically simplified. All private helper functions are **DELETED**. It contains only the new public API.

        ```python
        # src/rfsim_core/simulation/execution.py
        import logging
        import numpy as np
        from typing import Optional, Tuple

        from ..data_structures import Circuit
        from ..cache import SimulationCache
        from ..errors import SimulationRunError, Diagnosable, format_diagnostic_report
        from ..validation import SemanticValidator
        from ..validation.exceptions import SemanticValidationError
        from .context import SimulationContext
        from .engine import SimulationEngine
        from .results import SimulationResult
        from ..analysis.results import DCAnalysisResults

        logger = logging.getLogger(__name__)

        def run_sweep(
            circuit: Circuit,
            freq_array_hz: np.ndarray,
            cache: Optional[SimulationCache] = None
        ) -> Tuple[SimulationResult, SimulationCache]:
            """
            The primary public API for running a hierarchical frequency sweep simulation.
            
            This function acts as a Facade, providing a simple entry point to the powerful
            underlying simulation engine and caching services.
            
            Args:
                circuit: The simulation-ready top-level Circuit object.
                freq_array_hz: A NumPy array of frequencies (in Hz) for the sweep.
                cache: An optional SimulationCache instance. If provided, its process-level
                       cache will be reused. If None, a new cache is created for this run.
            
            Returns:
                A tuple containing:
                - result: A SimulationResult object with the final simulation data.
                - used_cache: The cache instance used for the run. This can be passed back
                              into a subsequent call to `run_sweep` to leverage the
                              persistent process-level cache for performance.
            """
            effective_cache = cache if cache is not None else SimulationCache()
            try:
                validator = SemanticValidator(circuit)
                issues = validator.validate()
                if any(issue.level == "ERROR" for issue in issues):
                    raise SemanticValidationError(issues)

                context = SimulationContext(circuit, freq_array_hz, effective_cache)
                engine = SimulationEngine(context)
                y_mats, dc_res = engine.execute_sweep()
                
                result = SimulationResult(freq_array_hz, y_mats, dc_res)
                logger.info(f"Simulation sweep successful. Cache stats: {effective_cache.get_stats()}")
                return result, effective_cache
            
            except Diagnosable as e:
                raise SimulationRunError(e.get_diagnostic_report()) from e
            except Exception as e:
                report = format_diagnostic_report(
                    error_type=f"An Unexpected Simulation Error Occurred ({type(e).__name__})",
                    details=f"The simulator encountered an unexpected internal error: {e}",
                    suggestion="This may be a bug. Review the traceback and consider filing a bug report.",
                    context={}
                )
                raise SimulationRunError(report) from e
        ```

#### **Task 5: Verification and Documentation**

*   **Goal:** Rigorously validate the new architecture and clearly document its principles and usage for both end-users and future developers.
*   **Rigorous Justification:** An untested or undocumented architecture is a liability. The tests must verify the correctness of the new patterns, proving that hidden state has been eliminated and caching works as designed. The documentation must explain the "why" behind the design to ensure it is maintained and extended correctly by future developers.
*   **Detailed Implementation Steps:**
    *   **5.1. Unit and Integration Tests (Mandatory Test Cases):**
        *   **`SimulationCache`:** Write tests for `get` and `put` for both `'run'` and `'process'` scopes independently. Write a critical test that:
            1. Creates two separate `SimulationCache` instances.
            2. Puts a value in the `'process'` scope of the first instance.
            3. Asserts that `get` on the *second* instance returns that same value.
            4. Verifies `clear_process_cache` works as expected.
        *   **Analysis Service Caching:** Write a test that:
            1.  Creates a hierarchical circuit and a `SimulationCache` instance.
            2.  Instantiates `DCAnalyzer` for a subcircuit, injecting the cache. Calls `analyze()`.
            3.  Instantiates a *new* `DCAnalyzer` for the *same* subcircuit with the *same* cache. Calls `analyze()`.
            4.  Asserts that `cache.get_stats()` shows exactly one `'process'` scope MISS and one `'process'` scope HIT.
            5.  Repeat this entire test for `TopologyAnalyzer`.
        *   **Full Integration and Performance Verification:**
            1.  Run the benchmark test from Task 0 against the **completed Phase 10 codebase**.
            2.  **Assert that the new timing is not significantly worse (e.g., within a 5-10% tolerance) than the recorded baseline.** This is the final, non-negotiable gatekeeper that proves the vectorized execution model was successfully preserved.

    *   **5.2. Documentation Update (Mandatory Sections):**
        *   **User Guide:**
            *   Update the "Running a Simulation" section to show the new `run_sweep` signature and its return values. Explain the `SimulationResult` object and how to access its attributes (`.frequencies_hz`, `.y_parameters`).
            *   Add a new section: **"Caching and Performance."** Explain the two cache scopes (`run`, `process`). Provide a clear code example showing how to reuse the `SimulationCache` object for significant performance gains across multiple `run_sweep` calls.
        *   **Developer/Architecture Guide:**
            *   Create a new page: **"The Simulation Services Architecture."**
            *   Explain the roles of `SimulationContext` (State), `SimulationEngine` (Logic), `SimulationCache`, and the `Analysis Tools` as services. Use a diagram to illustrate the relationships.
            *   Explain the **Facade** pattern used in the public API (`run_sweep`) and why it's beneficial for users by hiding internal complexity.
            *   Explain the **Dependency Injection** pattern as the standard way to provide services like caching, using `DCAnalyzer` as the canonical example. This provides a clear, documented blueprint for all future developers who wish to add new analysis capabilities.

---

CODEBASE:

---

rfsim_core/
    pyproject.toml
        [project]
        name = "rfsim-core"
        version = "0.1.0"
        description = "Core foundation for RF Sim"
        readme = "README.md"
        requires-python = ">=3.13"
        dependencies = [
            "cerberus>=1.3.7",
            "networkx>=3.4.2",
            "numpy>=2.2.5",
            "pint>=0.24.4",
            "pyyaml>=6.0.2",
            "scipy>=1.15.2",
            "sympy>=1.13.3",
        ]
        
        [dependency-groups]
        dev = [
            "pytest-benchmark>=5.1.0",
            "pytest>=8.3.5",
        ]
        
        [tool.pytest.ini_options]
        pythonpath = ["."]
    src/
        __init__.py
            from .rfsim_core import *
        rfsim_core/
            __init__.py
                # src/rfsim_core/__init__.py
                import logging
                from .log_config import setup_logging
                
                setup_logging()
                logger = logging.getLogger(__name__)
                logger.info("RFSim Core package initialized.")
                
                from .units import ureg, pint, Quantity, ADMITTANCE_DIMENSIONALITY, IMPEDANCE_DIMENSIONALITY
                from .data_structures import Circuit
                from .parser import NetlistParser
                from .circuit_builder import CircuitBuilder
                from .simulation import run_sweep, run_simulation
                from .errors import RFSimError, CircuitBuildError, SimulationRunError
                
                __all__ = [
                    # Units
                    "ureg", "pint", "Quantity",
                    # Canonical dimensionalities
                    "ADMITTANCE_DIMENSIONALITY", "IMPEDANCE_DIMENSIONALITY",
                    # Data Structures
                    "Circuit",
                    # Parser
                    "NetlistParser",
                    # Builder
                    "CircuitBuilder",
                    # Simulation
                    "run_sweep", "run_simulation",
                    # Top-Level Errors (Actionable Diagnostics)
                    "RFSimError", "CircuitBuildError", "SimulationRunError",
                ]
            analysis_tools.py
                # src/rfsim_core/analysis_tools.py
                
                """
                Provides high-level analysis tools for synthesized Circuit objects.
                
                This module contains the primary tools for pre-simulation analysis:
                - DCAnalyzer: Performs a rigorous DC (F=0) analysis by identifying supernodes
                  created by ideal shorts and solving a reduced system.
                - TopologyAnalyzer: Performs a structural analysis to identify active parts of
                  the circuit for AC simulation, correctly handling structural opens and leveraging
                  a persistent cache for hierarchical efficiency.
                """
                
                import logging
                from typing import Dict, Any, Optional, List, Tuple, Set
                from itertools import combinations
                
                import networkx as nx
                import numpy as np
                from scipy.linalg import lu_factor, lu_solve
                
                from .data_structures import Circuit
                
                # --- BEGIN Phase 9 Task 5 Change ---
                # Import the ComponentBase and DCBehaviorType (which is now in a separate file)
                from .components.base import ComponentBase, DCBehaviorType, ComponentError
                # NEW IMPORT: Import the IDcContributor protocol to enable decoupled DC analysis.
                from .components.capabilities import IDcContributor
                # --- END Phase 9 Task 5 Change ---
                
                from .components.subcircuit import SubcircuitInstance
                from .units import ureg, Quantity
                from .parameters import ParameterManager, ParameterError
                from .parser.raw_data import ParsedLeafComponentData
                
                # --- BEGIN Phase 9 Task 5 Thoughtful Enhancement ---
                # NEW IMPORT: Import the diagnosable DCAnalysisError from the simulation exceptions module.
                # This replaces the local, non-diagnosable ValueError subclass, aligning the DCAnalyzer
                # with the project's "Actionable Diagnostics" mandate for consistent, rich error reporting.
                from .simulation.exceptions import DCAnalysisError
                # --- END Phase 9 Task 5 Thoughtful Enhancement ---
                
                logger = logging.getLogger(__name__)
                
                
                # --- BEGIN Phase 9 Task 5 Thoughtful Enhancement ---
                # DELETED: The local, non-diagnosable DCAnalysisError class is removed.
                # class DCAnalysisError(ValueError):
                #     """Custom exception for errors during rigorous DC analysis."""
                #     pass
                # --- END Phase 9 Task 5 Thoughtful Enhancement ---
                
                
                class DCAnalyzer:
                    """
                    Performs a rigorous DC (F=0) analysis on a synthesized circuit.
                
                    The analysis follows these steps:
                    1.  Resolves all component parameters at F=0.
                    2.  Identifies all ideal DC shorts (e.g., R=0, L=0, C=inf).
                    3.  Builds a 'supernode' graph where nodes connected by ideal shorts are merged.
                    4.  Constructs a reduced MNA admittance matrix for the supernode topology.
                    5.  Solves for the N-port DC Y-parameters via Schur complement reduction.
                    """
                    def __init__(self, circuit: Circuit):
                        if not isinstance(circuit, Circuit) or not circuit.parameter_manager:
                            raise TypeError("DCAnalyzer requires a valid, simulation-ready Circuit object.")
                
                        self.circuit: Circuit = circuit
                        self.parameter_manager: ParameterManager = circuit.parameter_manager
                        self.ureg = ureg
                        self.ground_net_name: str = circuit.ground_net_name
                        self._supernode_map: Dict[str, str] = {}
                        self._ground_supernode_representative_name: Optional[str] = None
                        self._supernode_graph: Optional[nx.Graph] = None
                        self._supernode_to_mna_index_map: Dict[str, int] = {}
                        self._dc_port_names_ordered: List[str] = []
                        logger.info(f"DCAnalyzer initialized for circuit '{circuit.hierarchical_id}'.")
                
                    def analyze(self) -> Dict[str, Any]:
                        """
                        Executes the full DC analysis pipeline.
                
                        Returns:
                            A dictionary containing the DC analysis results, including:
                            - 'Y_ports_dc': The N-port DC admittance matrix as a pint.Quantity.
                            - 'dc_port_names_ordered': The ordered list of DC port names.
                            - 'dc_port_mapping': A map from original AC port names to DC port indices.
                            - 'dc_supernode_mapping': A map from original net names to their supernode representatives.
                        """
                        logger.info(f"Starting rigorous DC analysis for circuit '{self.circuit.hierarchical_id}'...")
                        dc_behaviors = self._resolve_and_collect_dc_behaviors()
                        self._build_dc_supernode_graph(dc_behaviors)
                        self._identify_supernodes()
                        self._assign_dc_mna_indices()
                        y_dc_super_full = self._build_dc_mna_matrix(dc_behaviors)
                        self._identify_dc_ports()
                        y_ports_dc_qty = self._calculate_dc_y_parameters(y_dc_super_full)
                        dc_port_mapping = self._build_dc_port_mapping()
                        logger.info(f"DC analysis for '{self.circuit.hierarchical_id}' complete.")
                        return {
                            'Y_ports_dc': y_ports_dc_qty,
                            'dc_port_names_ordered': self._dc_port_names_ordered,
                            'dc_port_mapping': dc_port_mapping,
                            'dc_supernode_mapping': self._supernode_map.copy()
                        }
                
                    def get_supernode_representative_name(self, original_net_name: str) -> Optional[str]:
                        """Gets the canonical representative name for a given net's supernode."""
                        return self._supernode_map.get(original_net_name, original_net_name)
                
                    def is_ground_supernode_by_representative(self, representative_supernode_name: str) -> bool:
                        """Checks if a representative name corresponds to the ground supernode."""
                        return representative_supernode_name == self._ground_supernode_representative_name
                
                    def _resolve_and_collect_dc_behaviors(self) -> Dict[str, Tuple[DCBehaviorType, Optional[Quantity]]]:
                        """Evaluates all parameters at F=0 and collects the DC behavior from each component."""
                        logger.debug(f"[{self.circuit.hierarchical_id}] Evaluating all parameters for DC (F=0)...")
                        try:
                            all_dc_params = self.parameter_manager.evaluate_all(np.array([0.0]))
                        except ParameterError as e:
                            raise DCAnalysisError(hierarchical_context=self.circuit.hierarchical_id, details=f"Failed to evaluate parameters for DC analysis: {e}") from e
                
                        dc_behaviors: Dict[str, Tuple[DCBehaviorType, Optional[Quantity]]] = {}
                        
                        # --- BEGIN Phase 9 Task 5 Change: Refactored DC Behavior Collection ---
                        for comp_id, sim_comp in self.circuit.sim_components.items():
                            try:
                                # STEP 1: Query for the DC capability.
                                dc_contributor = sim_comp.get_capability(IDcContributor)
                                
                                if dc_contributor:
                                    # STEP 2: If capability exists, call its method.
                                    # The `sim_comp` instance is passed as context.
                                    behavior_type, admittance_qty = dc_contributor.get_dc_behavior(sim_comp, all_dc_params)
                                    dc_behaviors[comp_id] = (behavior_type, admittance_qty)
                                else:
                                    # STEP 3: If no capability, apply a robust default.
                                    # This makes the system extensible. A future non-electrical component, for example,
                                    # can be added without needing a `get_dc_behavior` method; it will safely be
                                    # treated as an open circuit in the DC analysis.
                                    dc_behaviors[comp_id] = (DCBehaviorType.OPEN_CIRCUIT, None)
                                    
                            except (ComponentError, KeyError) as e:
                                # The exception is now wrapped in the richer, diagnosable DCAnalysisError.
                                details = f"Error getting DC behavior for component '{sim_comp.fqn}': {e}"
                                logger.error(details, exc_info=True)
                                raise DCAnalysisError(
                                    hierarchical_context=self.circuit.hierarchical_id,
                                    details=details
                                ) from e
                        # --- END Phase 9 Task 5 Change ---
                        return dc_behaviors
                
                    def _build_dc_supernode_graph(self, dc_behaviors: Dict[str, Tuple[DCBehaviorType, Optional[Quantity]]]):
                        """Constructs a graph where edges represent ideal DC shorts between nets."""
                        logger.debug(f"[{self.circuit.hierarchical_id}] Building DC supernode connectivity graph...")
                        self._supernode_graph = nx.Graph()
                        self._supernode_graph.add_nodes_from(self.circuit.nets.keys())
                
                        for comp_id, (behavior_type, _) in dc_behaviors.items():
                            if behavior_type != DCBehaviorType.SHORT_CIRCUIT:
                                continue
                
                            sim_comp = self.circuit.sim_components[comp_id]
                            raw_comp_data = sim_comp.raw_ir_data
                            
                            if not isinstance(raw_comp_data, ParsedLeafComponentData):
                                logger.error(
                                    f"Internal contract violation: Component '{sim_comp.fqn}' reported as a DC "
                                    "short but is not a leaf component. This is an impossible state and will be ignored."
                                )
                                continue
                            
                            connected_nets = [
                                net_name for net_name in raw_comp_data.raw_ports_dict.values()
                                if net_name in self.circuit.nets
                            ]
                
                            if len(connected_nets) >= 2:
                                for net1, net2 in combinations(sorted(list(set(connected_nets))), 2):
                                    self._supernode_graph.add_edge(net1, net2, type='dc_short', component_id=comp_id)
                
                    def _identify_supernodes(self):
                        """Finds connected components in the shorting graph to define supernodes."""
                        if self._supernode_graph is None: raise DCAnalysisError(hierarchical_context=self.circuit.hierarchical_id, details="Supernode graph was not built.")
                        self._supernode_map = {net: net for net in self.circuit.nets}
                        for component_nets in nx.connected_components(self._supernode_graph):
                            is_gnd_component = self.ground_net_name in component_nets
                            representative_name = self.ground_net_name if is_gnd_component else sorted(list(component_nets))[0]
                            for net_name in component_nets:
                                self._supernode_map[net_name] = representative_name
                        self._ground_supernode_representative_name = self._supernode_map.get(self.ground_net_name)
                
                    def _assign_dc_mna_indices(self):
                        """Assigns a unique integer index to each supernode for MNA matrix assembly."""
                        if not self._supernode_map: raise DCAnalysisError(hierarchical_context=self.circuit.hierarchical_id, details="Supernode map not populated.")
                        if self._ground_supernode_representative_name is None: raise DCAnalysisError(hierarchical_context=self.circuit.hierarchical_id, details="Ground supernode not identified.")
                        
                        representatives = sorted(list(set(self._supernode_map.values())))
                        self._supernode_to_mna_index_map = {self._ground_supernode_representative_name: 0}
                        idx_counter = 1
                        for rep in representatives:
                            if rep != self._ground_supernode_representative_name:
                                self._supernode_to_mna_index_map[rep] = idx_counter
                                idx_counter += 1
                
                    def _build_dc_mna_matrix(self, dc_behaviors: Dict[str, Tuple[DCBehaviorType, Optional[Quantity]]]) -> np.ndarray:
                        """Assembles the full supernode MNA admittance matrix from component contributions."""
                        num_dc_nodes = len(self._supernode_to_mna_index_map)
                        if num_dc_nodes == 0: return np.array([], dtype=complex).reshape(0, 0)
                        
                        y_dc_super_full = np.zeros((num_dc_nodes, num_dc_nodes), dtype=complex)
                        for comp_id, (behavior_type, admittance_qty) in dc_behaviors.items():
                            if behavior_type != DCBehaviorType.ADMITTANCE or admittance_qty is None:
                                continue
                
                            sim_comp = self.circuit.sim_components[comp_id]
                            if isinstance(sim_comp, SubcircuitInstance):
                                y_sub_mag = admittance_qty.to(self.ureg.siemens).magnitude
                                port_map = sim_comp.raw_ir_data.raw_port_mapping
                                parent_indices = [
                                    self._supernode_to_mna_index_map[self.get_supernode_representative_name(port_map[p])]
                                    for p in sim_comp.sub_circuit_external_port_names_ordered
                                ]
                                for i, r_idx in enumerate(parent_indices):
                                    for j, c_idx in enumerate(parent_indices):
                                        y_dc_super_full[r_idx, c_idx] += y_sub_mag[i, j]
                            else:
                                y_mag = complex(admittance_qty.to(self.ureg.siemens).magnitude)
                                raw_comp = sim_comp.raw_ir_data
                                nets = [net for net in raw_comp.raw_ports_dict.values() if net in self.circuit.nets]
                                unique_srep_indices = {self._supernode_to_mna_index_map[self.get_supernode_representative_name(n)] for n in nets}
                                if len(unique_srep_indices) == 2:
                                    idx1, idx2 = tuple(unique_srep_indices)
                                    y_dc_super_full[idx1, idx1] += y_mag; y_dc_super_full[idx2, idx2] += y_mag
                                    y_dc_super_full[idx1, idx2] -= y_mag; y_dc_super_full[idx2, idx1] -= y_mag
                                elif len(unique_srep_indices) == 1:
                                    idx1 = unique_srep_indices.pop()
                                    y_dc_super_full[idx1, idx1] += y_mag
                        return y_dc_super_full
                
                    def _identify_dc_ports(self):
                        """Identifies which supernodes correspond to external AC ports."""
                        supernode_rep_to_ac_ports: Dict[str, List[str]] = {}
                        for port_name in self.circuit.external_ports:
                             srep = self.get_supernode_representative_name(port_name)
                             if srep is not None and not self.is_ground_supernode_by_representative(srep):
                                 supernode_rep_to_ac_ports.setdefault(srep, []).append(port_name)
                        self._dc_port_names_ordered = [sorted(ports)[0] for _, ports in sorted(supernode_rep_to_ac_ports.items())]
                
                    def _calculate_dc_y_parameters(self, y_dc_super_full: np.ndarray) -> Optional[Quantity]:
                        """Calculates the DC N-port Y-matrix using Schur complement reduction."""
                        num_dc_ports = len(self._dc_port_names_ordered)
                        if num_dc_ports == 0: return None
                        
                        port_indices = [self._supernode_to_mna_index_map[self.get_supernode_representative_name(n)] for n in self._dc_port_names_ordered]
                        internal_indices = sorted(list(set(range(1, y_dc_super_full.shape[0])) - set(port_indices)))
                        
                        Y_PP = y_dc_super_full[np.ix_(port_indices, port_indices)]
                        if not internal_indices: return Quantity(Y_PP, self.ureg.siemens)
                        
                        Y_PI = y_dc_super_full[np.ix_(port_indices, internal_indices)]
                        Y_IP = y_dc_super_full[np.ix_(internal_indices, port_indices)]
                        Y_II = y_dc_super_full[np.ix_(internal_indices, internal_indices)]
                        try:
                            X = lu_solve(lu_factor(Y_II), Y_IP)
                            y_ports_dc_mag = Y_PP - (Y_PI @ X)
                            return Quantity(y_ports_dc_mag, self.ureg.siemens)
                        except np.linalg.LinAlgError as e:
                            raise DCAnalysisError(hierarchical_context=self.circuit.hierarchical_id, details=f"Failed to compute DC Schur complement: {e}") from e
                
                    def _build_dc_port_mapping(self) -> Dict[str, Optional[int]]:
                        """Creates a map from original AC port names to their corresponding DC port indices."""
                        dc_port_mapping: Dict[str, Optional[int]] = {}
                        dc_port_to_idx = {name: i for i, name in enumerate(self._dc_port_names_ordered)}
                        srep_to_port_name = {self.get_supernode_representative_name(name): name for name in self._dc_port_names_ordered}
                        for ac_port in self.circuit.external_ports:
                            srep = self.get_supernode_representative_name(ac_port)
                            if srep is None or self.is_ground_supernode_by_representative(srep):
                                dc_port_mapping[ac_port] = None
                            else:
                                port_name = srep_to_port_name.get(srep)
                                dc_port_mapping[ac_port] = dc_port_to_idx.get(port_name)
                        return dc_port_mapping
                
                
                class TopologyAnalysisError(ValueError):
                    """Custom exception for errors during topological analysis."""
                    pass
                
                
                class TopologyAnalyzer:
                    """
                    Performs and caches topological analysis for a given circuit configuration.
                    (This class is not modified in Phase 9, Task 5)
                    """
                    _persistent_topology_cache: Dict[Tuple, Dict[str, Any]] = {}
                
                    def __init__(self, circuit: Circuit):
                        if not isinstance(circuit, Circuit) or not circuit.parameter_manager:
                            raise TypeError("TopologyAnalyzer requires a valid, simulation-ready Circuit object.")
                        
                        self.circuit: Circuit = circuit
                        self.parameter_manager: ParameterManager = circuit.parameter_manager
                        self._analysis_results: Optional[Dict[str, Any]] = None
                        logger.debug(f"TopologyAnalyzer initialized for circuit '{circuit.hierarchical_id}'.")
                
                    def _get_cache_key(self) -> Tuple[str, Tuple[Tuple[str, str], ...]]:
                        """Computes the definitive, hashable key for this circuit's topology."""
                        source_path_str = str(self.circuit.source_file_path)
                        
                        const_params = []
                        for p_def in self.circuit.parameter_manager.get_all_fqn_definitions():
                            if p_def.owner_fqn.startswith(self.circuit.hierarchical_id):
                                fqn = p_def.fqn
                                if self.parameter_manager.is_constant(fqn):
                                    try:
                                        val = self.parameter_manager.get_constant_value(fqn)
                                        const_params.append((fqn, f"{val:~P}"))
                                    except ParameterError as e:
                                        logger.warning(f"Could not resolve constant '{fqn}' for topology cache key: {e}")
                        
                        return (source_path_str, tuple(sorted(const_params)))
                
                    def analyze(self) -> Dict[str, Any]:
                        """Performs a full topological analysis, leveraging the persistent cache."""
                        if self._analysis_results is not None:
                            return self._analysis_results
                
                        cache_key = self._get_cache_key()
                        if cache_key in TopologyAnalyzer._persistent_topology_cache:
                            logger.debug(f"Cache HIT for topology of '{self.circuit.name}'.")
                            self._analysis_results = TopologyAnalyzer._persistent_topology_cache[cache_key]
                            return self._analysis_results
                
                        logger.debug(f"Cache MISS for topology of '{self.circuit.name}'. Performing full analysis.")
                        
                        open_comps = self._resolve_and_identify_structurally_open_components()
                        ac_graph = self._build_ac_graph(open_comps)
                        active_nets = self._compute_active_nets(ac_graph)
                        port_connectivity = self._compute_external_port_connectivity(ac_graph)
                        
                        results = {
                            "structurally_open_components": open_comps,
                            "ac_graph": ac_graph,
                            "active_nets": active_nets,
                            "external_port_connectivity": port_connectivity,
                        }
                
                        TopologyAnalyzer._persistent_topology_cache[cache_key] = results
                        self._analysis_results = results
                        return results
                
                    def get_active_nets(self) -> Set[str]:
                        """Returns the set of active nets for the circuit by running the analysis."""
                        return self.analyze()["active_nets"]
                
                    def are_ports_connected_to_active_ground(self) -> bool:
                        """Checks if any active external port has a path to the active ground."""
                        results = self.analyze()
                        ac_graph = results["ac_graph"]
                        if not self.circuit.external_ports: return True
                        ground_name = self.circuit.ground_net_name
                        if ground_name not in ac_graph: return False
                        
                        return any(nx.has_path(ac_graph, port, ground_name) for port in self.circuit.external_ports if port in ac_graph)
                
                    def _resolve_and_identify_structurally_open_components(self) -> Set[str]:
                        """Determines which leaf components are structural opens based on their constant parameters."""
                        open_comp_ids: Set[str] = set()
                        for comp_id, sim_comp in self.circuit.sim_components.items():
                            if isinstance(sim_comp, SubcircuitInstance): continue
                            
                            resolved_constant_params: Dict[str, Quantity] = {}
                            for base_param_name, fqn in zip(type(sim_comp).declare_parameters(), sim_comp.parameter_fqns):
                                if self.parameter_manager.is_constant(fqn):
                                    try:
                                        resolved_constant_params[base_param_name] = self.parameter_manager.get_constant_value(fqn)
                                    except ParameterError as e:
                                        logger.warning(f"Could not resolve constant '{fqn}' for structural open check: {e}")
                
                            if sim_comp.is_structurally_open(resolved_constant_params):
                                open_comp_ids.add(comp_id)
                        return open_comp_ids
                
                    def _build_ac_graph(self, structurally_open_components: Set[str]) -> nx.Graph:
                        """Builds the AC connectivity graph for this circuit level, recursively analyzing subcircuits."""
                        ac_graph = nx.Graph()
                        ac_graph.add_nodes_from(self.circuit.nets.keys())
                
                        for sim_comp in self.circuit.sim_components.values():
                            if sim_comp.instance_id in structurally_open_components:
                                continue
                
                            if isinstance(sim_comp, SubcircuitInstance):
                                sub_ta = TopologyAnalyzer(sim_comp.sub_circuit_object)
                                sub_results = sub_ta.analyze()
                                port_connectivity = sub_results["external_port_connectivity"]
                                
                                port_map = sim_comp.raw_ir_data.raw_port_mapping
                                for sub_port1, sub_port2 in port_connectivity:
                                    net1, net2 = port_map.get(sub_port1), port_map.get(sub_port2)
                                    if net1 and net2 and net1 in ac_graph and net2 in ac_graph:
                                        ac_graph.add_edge(net1, net2)
                            elif isinstance(sim_comp, ComponentBase):
                                raw_comp_data = sim_comp.raw_ir_data
                                if not isinstance(raw_comp_data, ParsedLeafComponentData): continue
                
                                nets = set(raw_comp_data.raw_ports_dict.values())
                                for net1, net2 in combinations(sorted(list(nets)), 2):
                                    if net1 in ac_graph and net2 in ac_graph:
                                        ac_graph.add_edge(net1, net2)
                        
                        return ac_graph
                
                    def _compute_active_nets(self, ac_graph: nx.Graph) -> Set[str]:
                        """Computes the set of all nets connected to ground or an external port."""
                        if not ac_graph.nodes: return set()
                        
                        sources = {p for p in self.circuit.external_ports if p in ac_graph}
                        if self.circuit.ground_net_name in ac_graph:
                            sources.add(self.circuit.ground_net_name)
                        if not sources: return set()
                
                        active_nets: Set[str] = set()
                        for source in sources:
                            if source in ac_graph and not nx.is_isolate(ac_graph, source):
                                active_nets.update(nx.node_connected_component(ac_graph, source))
                        return active_nets
                
                    def _compute_external_port_connectivity(self, ac_graph: nx.Graph) -> List[Tuple[str, str]]:
                        """Computes which pairs of this circuit's external ports are conductively connected."""
                        ext_ports = list(self.circuit.external_ports.keys())
                        connected_pairs = []
                        for port1, port2 in combinations(sorted(ext_ports), 2):
                            if port1 in ac_graph and port2 in ac_graph and nx.has_path(ac_graph, port1, port2):
                                connected_pairs.append((port1, port2))
                        return connected_pairs
            circuit_builder.py
                # src/rfsim_core/circuit_builder.py
                import logging
                from collections import ChainMap
                from typing import Dict, Any, List, Tuple, Set
                
                from .data_structures import Circuit, Net
                from .components.base import ComponentBase, COMPONENT_REGISTRY
                from .components.subcircuit import SubcircuitInstance
                from .parser.raw_data import (
                    ParsedCircuitNode,
                    ParsedLeafComponentData,
                    ParsedSubcircuitData,
                )
                from .parameters import (
                    ParameterManager,
                    ParameterDefinition,
                    ParameterDefinitionError,
                )
                from .errors import CircuitBuildError, Diagnosable, format_diagnostic_report
                
                
                logger = logging.getLogger(__name__)
                
                
                class CircuitBuilder:
                    """
                    Synthesizes a simulation-ready, hierarchical `Circuit` object from a parsed IR tree.
                
                    This class implements the "Correctness by Construction" and "Explicit Contracts"
                    mandates by transforming the raw, unlinked `ParsedCircuitNode` IR from the
                    parser into a final, linked, and simulation-ready `Circuit` model.
                
                    The process is a strict, two-pass pipeline:
                    1.  **Definition Collection Pass:** Recursively traverses the entire IR tree to
                        discover all parameter definitions, handle hierarchical overrides, and build
                        the lexical scope maps (`ChainMap`) for every parameter. This pass produces a
                        flat list of all final `ParameterDefinition` objects.
                
                    2.  **Model Synthesis Pass:** With the parameters fully defined, this pass
                        recursively traverses the IR tree again to instantiate the final `Circuit`
                        and `ComponentBase` simulation objects, linking them to a single global
                        `ParameterManager` and performing ground net unification.
                    """
                
                    def build_simulation_model(self, parsed_tree_root: ParsedCircuitNode) -> Circuit:
                        """
                        The main build-time entry point. Synthesizes the IR tree into a simulation model.
                        This method implements the top-level error handling for the entire build process.
                
                        Args:
                            parsed_tree_root: The root of the `ParsedCircuitNode` tree from the parser.
                
                        Returns:
                            The fully synthesized, simulation-ready, top-level `Circuit` object.
                
                        Raises:
                            CircuitBuildError: A user-facing, diagnosable error if any part of the
                                               build process fails.
                        """
                        logger.info(f"--- Starting circuit model synthesis for '{parsed_tree_root.circuit_name}' ---")
                        try:
                            # --- PASS 1: Collect all parameter definitions and build scopes ---
                            logger.debug("Starting Pass 1: Parameter Definition and Scope Collection...")
                            all_definitions, scope_maps = self._collect_and_scope_definitions(parsed_tree_root)
                            logger.debug("Pass 1 Complete. Collected %d final parameter definitions.", len(all_definitions))
                
                            # --- Instantiate and build the single, global ParameterManager ---
                            global_pm = ParameterManager()
                            global_pm.build(all_definitions, scope_maps)
                
                            # --- PASS 2: Synthesize the final simulation object tree ---
                            logger.debug("Starting Pass 2: Simulation Object Tree Synthesis...")
                            sim_circuit = self._synthesize_circuit_object_tree(parsed_tree_root, global_pm)
                            logger.debug("Pass 2 Complete. Final circuit object tree synthesized.")
                
                            logger.info(f"--- Circuit model synthesis for '{sim_circuit.name}' successful. ---")
                            return sim_circuit
                
                        except Diagnosable as e:
                            # Catch any well-defined, diagnosable error from the build process.
                            diagnostic_report = e.get_diagnostic_report()
                            raise CircuitBuildError(diagnostic_report) from e
                
                        except Exception as e:
                            # Catch all other unexpected errors for a graceful fallback report.
                            report = format_diagnostic_report(
                                error_type=f"An Unexpected Error Occurred ({type(e).__name__})",
                                details=f"The circuit builder encountered an unexpected internal error: {str(e)}",
                                suggestion="This may indicate a bug in RFSim Core. Please review the traceback, check for input errors, and if the problem persists, consider filing a bug report.",
                                context={}
                            )
                            raise CircuitBuildError(report) from e
                
                    def _collect_and_scope_definitions(
                        self,
                        ir_node: ParsedCircuitNode,
                        parent_scope: ChainMap = ChainMap(),
                        parent_fqn: str = "top"
                    ) -> Tuple[List[ParameterDefinition], Dict[str, ChainMap]]:
                        """
                        Recursively performs Pass 1: collecting parameter definitions and building scopes.
                
                        This method walks the IR tree, creating `ParameterDefinition` objects and the
                        `ChainMap` lexical scopes needed for the `ExpressionPreprocessor`. It correctly
                        handles subcircuit parameter overrides by replacing definitions from the
                        sub-tree with new ones.
                
                        Args:
                            ir_node: The current `ParsedCircuitNode` being processed.
                            parent_scope: The lexical scope of the parent circuit.
                            parent_fqn: The fully qualified name of the parent context.
                
                        Returns:
                            A tuple containing:
                            - A flat list of all final `ParameterDefinition` objects in this sub-tree.
                            - A dictionary mapping every parameter FQN to its correct `ChainMap` scope.
                        """
                        all_definitions: List[ParameterDefinition] = []
                        all_scope_maps: Dict[str, ChainMap] = {}
                        
                        # The local scope map contains FQNs for parameters defined at this level.
                        local_scope_map: Dict[str, str] = {}
                        current_scope = parent_scope.new_child(local_scope_map)
                
                        # Process top-level parameters in the current circuit definition file
                        for name, value_str in ir_node.raw_parameters_dict.items():
                            param_def = ParameterDefinition(
                                owner_fqn=parent_fqn,
                                base_name=name,
                                raw_value_or_expression_str=str(value_str),
                                source_yaml_path=ir_node.source_yaml_path,
                                declared_dimension_str="dimensionless" # Interface params are dimensionless by convention
                            )
                            all_definitions.append(param_def)
                            local_scope_map[name] = param_def.fqn
                            all_scope_maps[param_def.fqn] = current_scope
                
                        # Process all components defined in this file
                        for comp_ir in ir_node.components:
                            component_fqn = f"{parent_fqn}.{comp_ir.instance_id}"
                            
                            if isinstance(comp_ir, ParsedLeafComponentData):
                                if comp_ir.component_type not in COMPONENT_REGISTRY:
                                    # This will be caught by SemanticValidator. We skip here to prevent a crash.
                                    logger.warning(f"Skipping parameter collection for '{component_fqn}' due to unknown type '{comp_ir.component_type}'.")
                                    continue
                                
                                ComponentClass = COMPONENT_REGISTRY[comp_ir.component_type]
                                declared_params = ComponentClass.declare_parameters()
                
                                for param_name, expected_dim in declared_params.items():
                                    if param_name in comp_ir.raw_parameters_dict:
                                        param_def = ParameterDefinition(
                                            owner_fqn=component_fqn,
                                            base_name=param_name,
                                            raw_value_or_expression_str=str(comp_ir.raw_parameters_dict[param_name]),
                                            source_yaml_path=comp_ir.source_yaml_path,
                                            declared_dimension_str=expected_dim
                                        )
                                        all_definitions.append(param_def)
                                        local_scope_map[f"{comp_ir.instance_id}.{param_name}"] = param_def.fqn
                                        all_scope_maps[param_def.fqn] = current_scope
                
                            elif isinstance(comp_ir, ParsedSubcircuitData):
                                # Recursively process the subcircuit's definition first
                                sub_definitions, sub_scope_maps = self._collect_and_scope_definitions(
                                    ir_node=comp_ir.sub_circuit_definition_node,
                                    parent_scope=current_scope,
                                    parent_fqn=component_fqn
                                )
                                
                                # Create a map from a parameter's base name (or deep name) within the subcircuit
                                # to its full definition object. This is crucial for finding the correct
                                # `declared_dimension_str` when applying an override.
                                sub_def_lookup: Dict[str, ParameterDefinition] = {
                                    p.fqn.replace(f"{component_fqn}.", "", 1): p for p in sub_definitions
                                }
                                
                                # Apply overrides from the instance definition
                                for override_key, override_value in comp_ir.raw_parameter_overrides.items():
                                    if override_key not in sub_def_lookup:
                                        # This error is intentionally detailed for clear user feedback.
                                        raise ParameterDefinitionError(
                                            fqn=f"{component_fqn}(override)",
                                            user_input=override_key,
                                            source_yaml_path=comp_ir.source_yaml_path,
                                            details=f"Subcircuit instance '{comp_ir.instance_id}' attempts to override parameter '{override_key}', which does not exist in its definition ('{comp_ir.definition_file_path.name}')."
                                        )
                                    
                                    # Found the original definition to override.
                                    original_def = sub_def_lookup[override_key]
                                    
                                    # Create the new definition for the override. It uses the new value but
                                    # crucially inherits the declared dimension from the original definition.
                                    override_def = ParameterDefinition(
                                        owner_fqn=original_def.owner_fqn,
                                        base_name=original_def.base_name,
                                        raw_value_or_expression_str=str(override_value),
                                        source_yaml_path=comp_ir.source_yaml_path, # Source is the overriding file
                                        declared_dimension_str=original_def.declared_dimension_str
                                    )
                                    
                                    # Replace the original definition with the override.
                                    # This ensures the final flat list is correct.
                                    sub_definitions = [d for d in sub_definitions if d.fqn != original_def.fqn]
                                    sub_definitions.append(override_def)
                
                                # Add the final, potentially overridden, sub-definitions to the main list.
                                all_definitions.extend(sub_definitions)
                                all_scope_maps.update(sub_scope_maps)
                
                        return all_definitions, all_scope_maps
                
                    def _synthesize_circuit_object_tree(
                        self,
                        ir_node: ParsedCircuitNode,
                        global_pm: ParameterManager,
                        parent_fqn: str = "top",
                        ground_unification_map: Dict[str, Net] = None
                    ) -> Circuit:
                        """
                        Recursively performs Pass 2: instantiating all simulation-ready objects.
                
                        This method walks the IR tree a second time, creating the final `Circuit`, `Net`,
                        and `ComponentBase` (including `SubcircuitInstance`) objects. It ensures that
                        all objects are correctly linked and that there is only one canonical ground `Net`
                        object for the entire simulation.
                
                        Args:
                            ir_node: The current `ParsedCircuitNode` being processed.
                            global_pm: The single, fully-built global ParameterManager.
                            parent_fqn: The FQN of the parent context.
                            ground_unification_map: A dict passed by reference to ensure a single
                                                    canonical ground `Net` object is used everywhere.
                
                        Returns:
                            The synthesized `Circuit` object for the current level of the hierarchy.
                        """
                        if ground_unification_map is None:
                            ground_unification_map = {}
                
                        # --- Synthesize Nets for this circuit level ---
                        nets: Dict[str, Net] = {}
                        raw_net_names = {comp.raw_ports_dict[p] for comp in ir_node.components if isinstance(comp, ParsedLeafComponentData) for p in comp.raw_ports_dict}
                        raw_net_names.update({p_map for comp in ir_node.components if isinstance(comp, ParsedSubcircuitData) for p_map in comp.raw_port_mapping.values()})
                        raw_net_names.add(ir_node.ground_net_name)
                        raw_port_nets = {p['id'] for p in ir_node.raw_external_ports_list}
                        raw_net_names.update(raw_port_nets)
                        
                        for net_name in sorted(list(raw_net_names)):
                            is_ground = (net_name == ir_node.ground_net_name)
                            if is_ground:
                                if "canonical_ground" not in ground_unification_map:
                                    # First time we've seen a ground net; create and store it.
                                    ground_unification_map["canonical_ground"] = Net(name=ir_node.ground_net_name, is_ground=True)
                                # All nets named 'gnd' (or the specified ground name) point to the same object.
                                nets[net_name] = ground_unification_map["canonical_ground"]
                            else:
                                nets[net_name] = Net(name=net_name, is_external=(net_name in raw_port_nets))
                
                        # --- Synthesize Components for this circuit level ---
                        sim_components: Dict[str, ComponentBase] = {}
                        for comp_ir in ir_node.components:
                            component_fqn = f"{parent_fqn}.{comp_ir.instance_id}"
                            
                            if isinstance(comp_ir, ParsedLeafComponentData):
                                if comp_ir.component_type in COMPONENT_REGISTRY:
                                    ComponentClass = COMPONENT_REGISTRY[comp_ir.component_type]
                                    sim_components[comp_ir.instance_id] = ComponentClass(
                                        instance_id=comp_ir.instance_id,
                                        parameter_manager=global_pm,
                                        parent_hierarchical_id=parent_fqn,
                                        raw_ir_data=comp_ir
                                    )
                            elif isinstance(comp_ir, ParsedSubcircuitData):
                                # Recursively synthesize the subcircuit's definition first.
                                sub_circuit_obj = self._synthesize_circuit_object_tree(
                                    ir_node=comp_ir.sub_circuit_definition_node,
                                    global_pm=global_pm,
                                    parent_fqn=component_fqn,
                                    ground_unification_map=ground_unification_map
                                )
                                
                                sim_components[comp_ir.instance_id] = SubcircuitInstance(
                                    instance_id=comp_ir.instance_id,
                                    parameter_manager=global_pm,
                                    sub_circuit_object_ref=sub_circuit_obj,
                                    sub_circuit_external_port_names_ordered=sorted(list(sub_circuit_obj.external_ports.keys())),
                                    parent_hierarchical_id=parent_fqn,
                                    raw_ir_data=comp_ir
                                )
                
                        # --- Synthesize the final Circuit object for this level ---
                        external_ports = {p['id']: nets[p['id']] for p in ir_node.raw_external_ports_list}
                
                        circuit_obj = Circuit(
                            name=ir_node.circuit_name,
                            hierarchical_id=parent_fqn,
                            source_file_path=ir_node.source_yaml_path,
                            ground_net_name=ir_node.ground_net_name,
                            nets=nets,
                            sim_components=sim_components,
                            external_ports=external_ports,
                            parameter_manager=global_pm,
                            raw_ir_root=ir_node
                        )
                        return circuit_obj
            components/
                __init__.py
                    # --- Modify: src/rfsim_core/components/__init__.py ---
                    import logging
                    logger = logging.getLogger(__name__)
                    
                    # Import base first to define registry and decorator
                    from .base import (
                        ComponentBase, COMPONENT_REGISTRY, register_component, ComponentError,
                        DCBehaviorType
                    )
                    
                    # Import concrete elements to trigger registration
                    from .elements import Resistor, Capacitor, Inductor
                    
                    # --- Import constants if needed directly from components namespace (Optional) ---
                    # from ..constants import LARGE_ADMITTANCE_SIEMENS # Keep this commented unless explicitly desired
                    
                    logger.info(f"Available component types: {list(COMPONENT_REGISTRY.keys())}")
                    
                    __all__ = [
                        "ComponentBase",
                        "COMPONENT_REGISTRY",
                        "register_component",
                        "Resistor",
                        "Capacitor",
                        "Inductor",
                        "ComponentError",
                        "DCBehaviorType",
                    ]
                base.py
                    # src/rfsim_core/components/base.py
                    
                    import logging
                    import inspect  # NEW: For robust class hierarchy inspection.
                    from abc import ABC, abstractmethod
                    from typing import Dict, Any, List, Tuple, ClassVar, Optional, Type
                    
                    import numpy as np
                    
                    from ..units import ureg, Quantity
                    from ..parameters import ParameterManager
                    from ..parser.raw_data import ParsedComponentData
                    # --- NEW IMPORTS: The core of the capability system ---
                    from .capabilities import ComponentCapability, TCapability, IMnaContributor, IDcContributor
                    from .base_enums import DCBehaviorType  # Import from the new, separated file.
                    
                    
                    logger = logging.getLogger(__name__)
                    
                    
                    class ComponentError(ValueError):
                        """Custom exception for component-related errors during simulation or analysis."""
                        pass
                    
                    
                    # A type alias for MNA stamp information, retained for clarity.
                    StampInfo = Tuple[Quantity, List[str | int]]
                    
                    
                    class ComponentBase(ABC):
                        """
                        The abstract base class for all circuit components in RFSim Core.
                    
                        This class establishes the fundamental contract for component identity,
                        parameter declaration, and, most importantly, provides the queryable
                    
                        capability system that decouples components from analysis engines. It serves
                        as a provider of capabilities rather than a monolithic implementation of
                        all possible analysis behaviors.
                        """
                        component_type_str: ClassVar[str] = "BaseComponent"
                    
                        def __init__(
                            self,
                            instance_id: str,
                            parameter_manager: ParameterManager,
                            parent_hierarchical_id: str,
                            raw_ir_data: ParsedComponentData
                        ):
                            """
                            Initializes the base attributes of a component instance.
                    
                            Args:
                                instance_id: The unique ID of this component instance (e.g., 'R1').
                                parameter_manager: The single, global ParameterManager for the simulation.
                                parent_hierarchical_id: The FQN of the circuit containing this component.
                                raw_ir_data: A link to the raw, parsed data for this specific instance,
                                             essential for validation and diagnostics.
                            """
                            self.instance_id: str = instance_id
                            self.parameter_manager: ParameterManager = parameter_manager
                            self.parent_hierarchical_id: str = parent_hierarchical_id
                            self.raw_ir_data: ParsedComponentData = raw_ir_data
                            self.ureg = ureg
                    
                            # NEW: This instance-level cache is a critical performance optimization.
                            # It ensures that for a given component instance, each capability object
                            # is created only ONCE on its first request. This amortizes the cost
                            # of discovery and instantiation across the entire simulation.
                            self._capability_cache: Dict[Type[ComponentCapability], ComponentCapability] = {}
                            logger.debug(f"Initialized {type(self).__name__} '{self.fqn}'")
                    
                        @property
                        def fqn(self) -> str:
                            """The canonical, fully qualified name (FQN) of this component instance."""
                            if self.parent_hierarchical_id == "top":
                                return f"top.{self.instance_id}"
                            return f"{self.parent_hierarchical_id}.{self.instance_id}"
                    
                        @property
                        def parameter_fqns(self) -> List[str]:
                            """A list of the fully qualified names for this component's parameters."""
                            return [f"{self.fqn}.{base_name}" for base_name in self.declare_parameters()]
                    
                        # --- DELETED: The old, monolithic abstract methods have been removed. ---
                        # @abstractmethod
                        # def get_mna_stamps(...) -> List[StampInfo]: ...
                        # @abstractmethod
                        # def get_dc_behavior(...) -> Tuple[DCBehaviorType, Optional[Quantity]]: ...
                    
                        # --- NEW: The core methods of the capability system. ---
                    
                        @classmethod
                        def declare_capabilities(cls) -> Dict[Type[ComponentCapability], Type]:
                            """
                            Automatically discovers and returns the capabilities map by robustly
                            inspecting the class hierarchy (MRO).
                    
                            This method fulfills the 'Declarative and Robust Registration' mandate.
                            It introspects the component class's full Method Resolution Order (MRO)
                            to find nested classes decorated with `@provides`. This correctly handles
                            capabilities defined in parent classes, making the plugin API robust,
                            predictable, and intuitive for authors.
                    
                            Returns:
                                A dictionary mapping a capability Protocol (e.g., IMnaContributor) to the
                                nested class that provides its implementation.
                            """
                            discovered_capabilities = {}
                            # We iterate through the MRO to correctly handle inheritance. The MRO
                            # is ordered from the class itself to its parents, so the first
                            # implementation found for a given protocol is the most specific one.
                            for base_class in cls.__mro__:
                                # Use inspect.getmembers to find all members of the class.
                                for _, member_obj in inspect.getmembers(base_class):
                                    # Check for the magic attribute set by the @provides decorator.
                                    if hasattr(member_obj, '_implements_capability'):
                                        protocol = member_obj._implements_capability
                                        # Only add it if we haven't already found a more specific one.
                                        if protocol not in discovered_capabilities:
                                            discovered_capabilities[protocol] = member_obj
                            return discovered_capabilities
                    
                        def get_capability(self, capability_type: Type[TCapability]) -> Optional[TCapability]:
                            """
                            Queries the component instance for a specific capability.
                    
                            This is the sole, public-facing entry point for all analysis engines.
                            It implements a lazy-loading and caching pattern:
                            1. Checks the instance-level cache for an existing capability object.
                            2. If not found, it calls the class-level discovery method.
                            3. If declared, it instantiates the stateless capability implementation class.
                            4. The new instance is cached for future requests and returned.
                    
                            Args:
                                capability_type: The Protocol class representing the desired capability
                                                 (e.g., `IMnaContributor`).
                    
                            Returns:
                                An instance of the capability implementation if supported, otherwise `None`.
                            """
                            # 1. Check instance cache first for maximum performance.
                            if capability_type in self._capability_cache:
                                return self._capability_cache[capability_type]
                    
                            # 2. On cache miss, consult the class-level declaration via discovery.
                            declared = type(self).declare_capabilities()
                            impl_class = declared.get(capability_type)
                    
                            if impl_class:
                                # 3. Instantiate the stateless capability object.
                                # No arguments are passed; it's a stateless service object.
                                instance = impl_class()
                                
                                # 4. Cache the singleton instance and return it.
                                self._capability_cache[capability_type] = instance
                                return instance
                    
                            # Return None if the component does not support this capability.
                            return None
                    
                        # --- Abstract methods for core component definition (REMAINING) ---
                    
                        @classmethod
                        @abstractmethod
                        def declare_parameters(cls) -> Dict[str, str]:
                            """Declare parameter names and their expected physical dimensions as strings."""
                            pass
                    
                        @classmethod
                        @abstractmethod
                        def declare_ports(cls) -> List[str | int]:
                            """Declare the names/indices of the component's connection ports."""
                            pass
                    
                        @classmethod
                        def declare_connectivity(cls) -> List[Tuple[str | int, str | int]]:
                            """
                            Declare internal connectivity between ports for MNA sparsity pattern prediction.
                            The default implementation assumes full connectivity for components with >2 ports.
                            Override for performance with sparsely-connected multi-port components.
                            """
                            ports = cls.declare_ports()
                            if len(ports) == 2:
                                return [(ports[0], ports[1])]
                            elif len(ports) < 2:
                                return []
                            else:
                                logger.warning(
                                    f"Component type '{cls.component_type_str}' has > 2 ports ({ports}) but "
                                    f"uses default pairwise connectivity. Override declare_connectivity() "
                                    f"for accurate sparsity."
                                )
                                from itertools import combinations
                                return list(combinations(ports, 2))
                    
                        @abstractmethod
                        def is_structurally_open(self, resolved_constant_params: Dict[str, Quantity]) -> bool:
                            """
                            Determine if the component is a structural open based on constant parameters.
                            This is used for pre-simulation topological analysis to identify and remove
                            floating sub-circuits, improving performance and robustness.
                    
                            Args:
                                resolved_constant_params: A dictionary of this component's constant
                                                          parameter values, already resolved.
                    
                            Returns:
                                True if the component acts as a permanent open circuit, False otherwise.
                            """
                            pass
                        
                        # --- Concrete dunder methods for representation (REMAINING) ---
                    
                        def __str__(self) -> str:
                            return f"{type(self).__name__}('{self.fqn}')"
                    
                        def __repr__(self) -> str:
                            return f"{type(self).__name__}(fqn='{self.fqn}')"
                    
                    
                    # --- Global Component Registry and Decorator (REMAINING) ---
                    
                    COMPONENT_REGISTRY: Dict[str, type[ComponentBase]] = {}
                    
                    def register_component(type_str: str):
                        """
                        A class decorator to register a component class in the global component registry,
                        making it available to the netlist parser.
                        """
                        def decorator(cls: type[ComponentBase]):
                            if not issubclass(cls, ComponentBase):
                                raise TypeError(f"Class {cls.__name__} must inherit from ComponentBase.")
                            if type_str in COMPONENT_REGISTRY:
                                logger.warning(f"Component type '{type_str}' is being redefined/overwritten.")
                            cls.component_type_str = type_str
                            COMPONENT_REGISTRY[type_str] = cls
                            logger.info(f"Registered component type '{type_str}' -> {cls.__name__}")
                            return cls
                        return decorator
                base_enums.py
                    # src/rfsim_core/components/base_enums.py
                    from enum import Enum, auto
                    
                    
                    class DCBehaviorType(Enum):
                        """
                        Defines the different ways a component can behave at DC (F=0), which is
                        queried by the DCAnalyzer.
                        """
                        SHORT_CIRCUIT = auto()  # Behaves as a perfect short circuit (e.g., R=0).
                        OPEN_CIRCUIT = auto()   # Behaves as a perfect open circuit (e.g., C=finite).
                        ADMITTANCE = auto()     # Provides a finite admittance value or N-port matrix.
                capabilities.py
                    # src/rfsim_core/components/capabilities.py
                    """
                    Defines the foundational capability architecture for RFSim Core components.
                    
                    This module introduces the concept of "capabilities" using `typing.Protocol`.
                    This decouples analysis engines (like MnaAssembler, DCAnalyzer) from the
                    concrete component implementations. Instead of requiring components to inherit
                    from a monolithic base class with many abstract methods, analysis engines can
                    query a component instance to see if it provides a specific, required capability
                    (e.g., `IMnaContributor`).
                    
                    This architecture is mandated for its extensibility and maintainability, allowing
                    the future addition of new analysis domains (e.g., noise, harmonic balance)
                    without requiring breaking changes to the existing component API.
                    
                    Key elements:
                    - ComponentCapability: A marker protocol for all capabilities.
                    - IMnaContributor, IDcContributor: Specific protocols defining the contracts for
                      contributing to MNA and DC analysis, respectively.
                    - @provides: A class decorator for declaratively registering a class as an
                      implementation of a specific capability. This automates discovery and
                      improves the developer experience for plugin authors.
                    - TCapability: A TypeVar for precise type-hinting of capability queries.
                    """
                    
                    import logging
                    from typing import Protocol, Type, Dict, Optional, List, Tuple, TypeVar, TYPE_CHECKING
                    import numpy as np
                    
                    # These imports are essential to define the method signatures correctly.
                    from ..units import Quantity
                    from .base_enums import DCBehaviorType  # Import from new, separated file.
                    
                    # Use TYPE_CHECKING to import ComponentBase only for type analysis,
                    # preventing a circular import at runtime.
                    if TYPE_CHECKING:
                        from .base import ComponentBase
                    
                    logger = logging.getLogger(__name__)
                    
                    
                    class ComponentCapability(Protocol):
                        """
                        A marker protocol for all component capabilities. Any class that provides
                        a specific functionality to an analysis engine should conform to a
                        protocol that inherits from this one.
                        """
                        pass
                    
                    
                    # TCapability is a TypeVar bound to ComponentCapability. This allows for precise
                    # type-hinting in `ComponentBase.get_capability`, ensuring that a request for
                    # `IMnaContributor` is known by the type checker to return an `IMnaContributor`.
                    TCapability = TypeVar("TCapability", bound=ComponentCapability)
                    
                    
                    class IMnaContributor(ComponentCapability):
                        """
                        Defines the capability of a component to contribute to a linear,
                        frequency-domain MNA system.
                    
                        ARCHITECTURAL CONTRACT:
                        This method MUST be a vectorized operation. It accepts the full array of
                        simulation frequencies and is expected to return the MNA stamp contributions
                        for all frequencies in a single, efficient computation. This is critical for
                        maintaining simulation performance. The simulation executive will call this
                        method ONCE, before the per-frequency loop begins.
                        """
                        def get_mna_stamps(
                            self,
                            component: 'ComponentBase',  # The component instance provides context.
                            freq_hz_array: np.ndarray,
                            all_evaluated_params: Dict[str, Quantity]
                        ) -> List[Tuple[Quantity, List[str | int]]]:
                            ...
                    
                    
                    class IDcContributor(ComponentCapability):
                        """
                        Defines the capability of a component to contribute to a DC (F=0) analysis.
                        The signature MUST match the data-passing requirements of the DCAnalyzer.
                        """
                        def get_dc_behavior(
                            self,
                            component: 'ComponentBase',  # The component instance provides context.
                            all_dc_params: Dict[str, Quantity]
                        ) -> Tuple[DCBehaviorType, Optional[Quantity]]:
                            ...
                    
                    
                    def provides(capability_protocol: Type[ComponentCapability]):
                        """
                        A class decorator to register a class as an implementation for a capability.
                    
                        This decorator attaches a private attribute, `_implements_capability`, to the
                        decorated class. The `ComponentBase.declare_capabilities` method will use this
                        attribute for automatic discovery. This implements the 'Declarative Registration'
                        mandate, making the API robust and easy to use for plugin authors.
                    
                        Args:
                            capability_protocol: The capability Protocol (e.g., IMnaContributor)
                                                 that this class implements.
                        """
                        def decorator(cls: Type) -> Type:
                            if not issubclass(capability_protocol, ComponentCapability):
                                 raise TypeError(
                                    f"Decorator argument for @provides must be a ComponentCapability "
                                    f"Protocol, but got {capability_protocol}."
                                 )
                            # Attach the metadata directly to the implementation class.
                            cls._implements_capability = capability_protocol
                            logger.debug(f"Class '{cls.__name__}' registered as providing capability '{capability_protocol.__name__}'.")
                            return cls
                        return decorator
                elements.py
                    # src/rfsim_core/components/elements.py
                    
                    """
                    This module provides the concrete implementations for the fundamental, "leaf-level"
                    passive circuit elements: Resistor, Capacitor, and Inductor.
                    
                    **Architectural Refactoring (Phase 9):**
                    
                    This module has been refactored to align with the capability-based component model.
                    The key architectural changes are as follows:
                    
                    1.  **Cohesion of Implementation:** All logic related to a specific analysis domain
                        (e.g., MNA, DC) is now encapsulated within a dedicated, stateless, nested class
                        inside its parent component class (e.g., `Resistor.MnaContributor`). This makes
                        the component's total functionality self-contained and highly discoverable.
                    
                    2.  **Declarative Registration:** The new `@provides` decorator is used on these
                        nested classes to declaratively register them as implementers of a specific
                        capability protocol (e.g., `IMnaContributor`). This automates discovery and
                        removes the burden of manual registration from the component author.
                    
                    3.  **Decoupled Interface:** The top-level component classes (`Resistor`, `Capacitor`,
                        `Inductor`) no longer contain direct implementations of `get_mna_stamps` or
                        `get_dc_behavior`. Instead, analysis engines will query for these capabilities
                        using `component.get_capability(IMnaContributor)`. This change completes the
                        decoupling of analysis logic from component implementation.
                    
                    4.  **Stateless Capability with Context:** The nested capability implementation classes
                        are stateless. When their methods are called by the framework, they receive the
                        parent component instance as an explicit first argument (e.g., `component: 'Resistor'`).
                        This provides all necessary context (like the component's FQN or parameter list)
                        for the calculation, while maintaining a clean, service-oriented design.
                    
                    The logic within the capability methods (`get_mna_stamps`, `get_dc_behavior`) remains
                    identical to the pre-refactoring implementation, merely relocated to its new,
                    architecturally-sound home. This ensures that the component's behavior is preserved
                    while its structure is vastly improved for future extensibility.
                    """
                    
                    import logging
                    import numpy as np
                    from typing import Dict, List, Optional, Tuple
                    
                    # --- Foundational Imports ---
                    from ..units import ureg, Quantity
                    from ..constants import LARGE_ADMITTANCE_SIEMENS
                    
                    # --- Core Component Model Imports ---
                    # Import the base classes and enums required for component definition.
                    from .base import (
                        ComponentBase, register_component, ComponentError, StampInfo
                    )
                    from .base_enums import DCBehaviorType
                    
                    # --- Capability System Imports (The Heart of the New Architecture) ---
                    # Import the capability protocols and the registration decorator.
                    from .capabilities import IMnaContributor, IDcContributor, provides
                    
                    
                    logger = logging.getLogger(__name__)
                    
                    # Define port constants for clarity and to prevent magic numbers.
                    PORT_1 = 0
                    PORT_2 = 1
                    
                    def _extract_dc_real_scalar_value(
                        all_dc_params: Dict[str, Quantity],
                        param_fqn: str,
                        component_fqn: str
                    ) -> float:
                        """
                        A stateless helper to robustly extract a single, real, scalar float value
                        from a resolved DC parameter. This function remains unchanged as it serves
                        as a utility for the DCContributor capabilities.
                        """
                        try:
                            # DC evaluation returns a Quantity with a 1-element array; extract the scalar.
                            qty = all_dc_params[param_fqn][0]
                            mag = qty.magnitude
                    
                            if np.iscomplexobj(mag) and mag.imag != 0:
                                raise ComponentError(f"Parameter '{param_fqn}' for DC analysis for '{component_fqn}' must be real. Got {qty:~P}.")
                    
                            real_val = float(mag.real if np.iscomplexobj(mag) else mag)
                            return real_val
                        except KeyError:
                            raise ComponentError(f"Parameter '{param_fqn}' not found for DC analysis of {component_fqn}.")
                        except (TypeError, ValueError) as e:
                            raise ComponentError(f"Could not convert DC parameter '{param_fqn}' of '{component_fqn}' to a scalar float: {e}") from e
                    
                    
                    @register_component("Resistor")
                    class Resistor(ComponentBase):
                        """Represents an ideal Resistor component."""
                    
                        # --- Capability Implementations are Nested Here ---
                        # This section contains the implementations for all capabilities this component provides.
                    
                        @provides(IMnaContributor)
                        class MnaContributor:
                            """Stateless implementation of the MNA contribution capability for a Resistor."""
                            def get_mna_stamps(
                                self,
                                component: 'Resistor',  # The component instance provides context.
                                freq_hz_array: np.ndarray,
                                all_evaluated_params: Dict[str, Quantity]
                            ) -> List[StampInfo]:
                                """
                                Calculates the vectorized MNA stamp for the Resistor. The logic is
                                moved verbatim from the old Resistor.get_mna_stamps method.
                                """
                                param_fqn = component.parameter_fqns[0]
                                r_qty = all_evaluated_params[param_fqn]
                                r_mag_si = r_qty.to(ureg.ohm).magnitude
                    
                                if np.any(np.iscomplex(r_mag_si)) and np.any(r_mag_si.imag != 0):
                                    raise ComponentError(f"Resistance must be real for {component.fqn}. Got a complex value.")
                    
                                r_real_mag = r_mag_si.real if np.any(np.iscomplex(r_mag_si)) else r_mag_si
                                if np.any(r_real_mag < 0):
                                    raise ComponentError(f"Resistance must be non-negative for {component.fqn}. Got a negative value.")
                    
                                y_mag_si = np.empty_like(r_real_mag, dtype=np.complex128)
                    
                                # Handle non-ideal case first for numerical stability
                                non_ideal_mask = (r_real_mag > 0) & np.isfinite(r_real_mag)
                                y_mag_si[non_ideal_mask] = 1.0 / r_real_mag[non_ideal_mask]
                    
                                # Patch ideal cases
                                y_mag_si[r_real_mag == 0] = LARGE_ADMITTANCE_SIEMENS
                                y_mag_si[np.isposinf(r_real_mag)] = 0.0
                    
                                num_freqs = len(freq_hz_array)
                                stamp_mag = np.zeros((num_freqs, 2, 2), dtype=np.complex128)
                                stamp_mag[:, 0, 0] = y_mag_si
                                stamp_mag[:, 1, 1] = y_mag_si
                                stamp_mag[:, 0, 1] = -y_mag_si
                                stamp_mag[:, 1, 0] = -y_mag_si
                    
                                return [(Quantity(stamp_mag, ureg.siemens), [PORT_1, PORT_2])]
                    
                        @provides(IDcContributor)
                        class DcContributor:
                            """Stateless implementation of the DC contribution capability for a Resistor."""
                            def get_dc_behavior(
                                self,
                                component: 'Resistor',  # The component instance provides context.
                                all_dc_params: Dict[str, Quantity]
                            ) -> Tuple[DCBehaviorType, Optional[Quantity]]:
                                """
                                Determines the Resistor's behavior at F=0. The logic is moved
                                verbatim from the old Resistor.get_dc_behavior method.
                                """
                                param_fqn = component.parameter_fqns[0]
                                r_real_val = _extract_dc_real_scalar_value(all_dc_params, param_fqn, component.fqn)
                    
                                if np.isnan(r_real_val) or np.isposinf(r_real_val):
                                    return (DCBehaviorType.OPEN_CIRCUIT, None)
                                if r_real_val == 0.0:
                                    return (DCBehaviorType.SHORT_CIRCUIT, None)
                                if r_real_val < 0:
                                    raise ComponentError(f"Negative resistance R={all_dc_params[param_fqn][0]:~P} not supported for DC analysis for '{component.fqn}'.")
                    
                                return (DCBehaviorType.ADMITTANCE, (1.0 / all_dc_params[param_fqn][0]).to(ureg.siemens))
                    
                        # --- Component's Own Declarations Follow ---
                        # These methods define the component's static interface and remain on the main class.
                    
                        @classmethod
                        def declare_parameters(cls) -> Dict[str, str]:
                            return {"resistance": "ohm"}
                    
                        @classmethod
                        def declare_ports(cls) -> List[str | int]:
                            return [PORT_1, PORT_2]
                    
                        def is_structurally_open(self, resolved_constant_params: Dict[str, Quantity]) -> bool:
                            if 'resistance' not in resolved_constant_params: return False
                            return bool(np.isposinf(resolved_constant_params['resistance'].magnitude))
                    
                    
                    @register_component("Capacitor")
                    class Capacitor(ComponentBase):
                        """Represents an ideal Capacitor component."""
                    
                        # --- Capability Implementations are Nested Here ---
                    
                        @provides(IMnaContributor)
                        class MnaContributor:
                            """Stateless implementation of the MNA contribution capability for a Capacitor."""
                            def get_mna_stamps(
                                self, component: 'Capacitor', freq_hz_array: np.ndarray, all_evaluated_params: Dict[str, Quantity]
                            ) -> List[StampInfo]:
                                param_fqn = component.parameter_fqns[0]
                                c_qty = all_evaluated_params[param_fqn]
                    
                                if np.any(np.iscomplex(c_qty.magnitude)):
                                    raise ComponentError(f"Capacitance must be real for {component.fqn}.")
                                if np.any(c_qty.magnitude < 0):
                                    raise ComponentError(f"Capacitance must be non-negative for {component.fqn}.")
                    
                                omega = (2 * np.pi * freq_hz_array) * (ureg.rad / ureg.second)
                                y_qty = (1j * omega * c_qty)
                    
                                # Create a complex array for admittances in Siemens.
                                y_mag_si = np.full_like(freq_hz_array, 0j, dtype=np.complex128)
                                
                                # Vectorized calculation for finite, non-zero capacitance
                                c_mag = c_qty.magnitude
                                finite_mask = (c_mag > 0) & np.isfinite(c_mag)
                                y_mag_si[finite_mask] = y_qty.to(ureg.siemens).magnitude[finite_mask]
                    
                                # Patch ideal cases
                                y_mag_si[np.isposinf(c_mag)] = LARGE_ADMITTANCE_SIEMENS + 0j
                                y_mag_si[c_mag == 0] = 0j
                    
                                num_freqs = len(freq_hz_array)
                                stamp_mag = np.zeros((num_freqs, 2, 2), dtype=np.complex128)
                                stamp_mag[:, 0, 0] = y_mag_si
                                stamp_mag[:, 1, 1] = y_mag_si
                                stamp_mag[:, 0, 1] = -y_mag_si
                                stamp_mag[:, 1, 0] = -y_mag_si
                    
                                return [(Quantity(stamp_mag, ureg.siemens), [PORT_1, PORT_2])]
                    
                        @provides(IDcContributor)
                        class DcContributor:
                            """Stateless implementation of the DC contribution capability for a Capacitor."""
                            def get_dc_behavior(
                                self, component: 'Capacitor', all_dc_params: Dict[str, Quantity]
                            ) -> Tuple[DCBehaviorType, Optional[Quantity]]:
                                param_fqn = component.parameter_fqns[0]
                                c_real_val = _extract_dc_real_scalar_value(all_dc_params, param_fqn, component.fqn)
                    
                                if np.isposinf(c_real_val):
                                    # An infinite capacitor is a perfect short at DC (stores infinite charge for any voltage).
                                    return (DCBehaviorType.SHORT_CIRCUIT, None)
                                if c_real_val < 0:
                                    raise ComponentError(f"Negative capacitance C={all_dc_params[param_fqn][0]:~P} not supported for DC analysis for '{component.fqn}'.")
                    
                                # C=0, finite C > 0, or C=NaN are all perfect open circuits at DC.
                                return (DCBehaviorType.OPEN_CIRCUIT, None)
                    
                        # --- Component's Own Declarations Follow ---
                    
                        @classmethod
                        def declare_parameters(cls) -> Dict[str, str]:
                            return {"capacitance": "farad"}
                    
                        @classmethod
                        def declare_ports(cls) -> List[str | int]:
                            return [PORT_1, PORT_2]
                    
                        def is_structurally_open(self, resolved_constant_params: Dict[str, Quantity]) -> bool:
                            if 'capacitance' not in resolved_constant_params: return False
                            # A zero-value capacitor is a permanent open circuit across all frequencies.
                            return resolved_constant_params['capacitance'].magnitude == 0
                    
                    
                    @register_component("Inductor")
                    class Inductor(ComponentBase):
                        """Represents an ideal Inductor component."""
                    
                        # --- Capability Implementations are Nested Here ---
                    
                        @provides(IMnaContributor)
                        class MnaContributor:
                            """Stateless implementation of the MNA contribution capability for an Inductor."""
                            def get_mna_stamps(
                                self, component: 'Inductor', freq_hz_array: np.ndarray, all_evaluated_params: Dict[str, Quantity]
                            ) -> List[StampInfo]:
                                param_fqn = component.parameter_fqns[0]
                                l_qty = all_evaluated_params[param_fqn]
                    
                                if np.any(np.iscomplex(l_qty.magnitude)):
                                    raise ComponentError(f"Inductance must be real for {component.fqn}.")
                                if np.any(l_qty.magnitude < 0):
                                    raise ComponentError(f"Inductance must be non-negative for {component.fqn}.")
                    
                                omega = (2 * np.pi * freq_hz_array) * (ureg.rad / ureg.second)
                                impedance_qty = (1j * omega * l_qty).to(ureg.ohm)
                                y_mag_si = np.empty_like(impedance_qty.magnitude, dtype=np.complex128)
                    
                                # Use a mask to avoid division by zero for ideal shorts at F>0
                                # and to handle the F=0 case separately.
                                l_mag = l_qty.magnitude
                                non_zero_impedance_mask = (impedance_qty.magnitude != 0) & (np.isfinite(l_mag))
                                with np.errstate(divide='ignore', invalid='ignore'):
                                     y_mag_si[non_zero_impedance_mask] = 1.0 / impedance_qty.magnitude[non_zero_impedance_mask]
                    
                                # Patch ideal cases
                                y_mag_si[impedance_qty.magnitude == 0] = LARGE_ADMITTANCE_SIEMENS + 0j
                                y_mag_si[np.isposinf(l_mag)] = 0j
                    
                                num_freqs = len(freq_hz_array)
                                stamp_mag = np.zeros((num_freqs, 2, 2), dtype=np.complex128)
                                stamp_mag[:, 0, 0] = y_mag_si
                                stamp_mag[:, 1, 1] = y_mag_si
                                stamp_mag[:, 0, 1] = -y_mag_si
                                stamp_mag[:, 1, 0] = -y_mag_si
                    
                                return [(Quantity(stamp_mag, ureg.siemens), [PORT_1, PORT_2])]
                    
                        @provides(IDcContributor)
                        class DcContributor:
                            """Stateless implementation of the DC contribution capability for an Inductor."""
                            def get_dc_behavior(
                                self, component: 'Inductor', all_dc_params: Dict[str, Quantity]
                            ) -> Tuple[DCBehaviorType, Optional[Quantity]]:
                                param_fqn = component.parameter_fqns[0]
                                l_real_val = _extract_dc_real_scalar_value(all_dc_params, param_fqn, component.fqn)
                    
                                if np.isposinf(l_real_val) or np.isnan(l_real_val):
                                    # An infinite inductor is a perfect open circuit.
                                    return (DCBehaviorType.OPEN_CIRCUIT, None)
                                if l_real_val < 0:
                                    raise ComponentError(f"Negative inductance L={all_dc_params[param_fqn][0]:~P} not supported for DC analysis for '{component.fqn}'.")
                    
                                # L=0 or any finite L > 0 are all perfect short circuits at DC.
                                return (DCBehaviorType.SHORT_CIRCUIT, None)
                    
                        # --- Component's Own Declarations Follow ---
                    
                        @classmethod
                        def declare_parameters(cls) -> Dict[str, str]:
                            return {"inductance": "henry"}
                    
                        @classmethod
                        def declare_ports(cls) -> List[str | int]:
                            return [PORT_1, PORT_2]
                    
                        def is_structurally_open(self, resolved_constant_params: Dict[str, Quantity]) -> bool:
                            if 'inductance' not in resolved_constant_params: return False
                            # An infinite-value inductor is a permanent open circuit across all frequencies.
                            return bool(np.isposinf(resolved_constant_params['inductance'].magnitude))
                subcircuit.py
                    # src/rfsim_core/components/subcircuit.py
                    
                    """
                    Provides the concrete implementation for the hierarchical `SubcircuitInstance` component.
                    
                    **Architectural Refactoring (Phase 9):**
                    
                    This module has been refactored to align with the capability-based component model,
                    serving as a crucial validation of the new architecture's ability to handle complex,
                    proxy-like components. The changes are as follows:
                    
                    1.  **Cohesion of Implementation:** All logic related to a specific analysis domain
                        (e.g., MNA, DC) is now encapsulated within a dedicated, stateless, nested class
                        inside its parent component class (e.g., `Resistor.MnaContributor`). This makes
                        the component's total functionality self-contained and highly discoverable.
                    
                    2.  **Declarative Registration:** The new `@provides` decorator is used on these
                        nested classes to declaratively register them as implementers of a specific
                        capability protocol (e.g., `IMnaContributor`). This automates discovery and
                        removes the burden of manual registration from the component author.
                    
                    3.  **Decoupled Interface:** `SubcircuitInstance` no longer directly implements
                        analysis-specific methods like `get_mna_stamps`. Instead, it acts as a container
                        for its cached simulation results and a provider of capabilities. Analysis engines
                        query it via `component.get_capability(...)`, completing the decoupling of analysis
                        logic from the component's structure.
                    
                    4.  **Stateless Capability with Context:** The nested capability classes are stateless.
                        When their methods are invoked by an analysis engine, they receive the parent
                        `SubcircuitInstance` object as an explicit `component` argument. This provides all
                        necessary context, such as the `fqn` for error messages and access to the critical
                        `cached_y_parameters_ac` and `cached_dc_analysis_results` attributes, while
                        maintaining a clean, service-oriented design.
                    """
                    
                    import logging
                    from typing import Dict, Any, List, Tuple, Optional, TYPE_CHECKING
                    
                    import numpy as np
                    
                    # --- Foundational Imports ---
                    from ..units import ureg, Quantity
                    from ..parameters import ParameterManager
                    from ..data_structures import Circuit
                    from ..parser.raw_data import ParsedSubcircuitData
                    
                    # --- Core Component Model Imports (Refactored) ---
                    from .base import (
                        ComponentBase,
                        register_component,
                        ComponentError,
                        StampInfo,
                    )
                    from .base_enums import DCBehaviorType
                    
                    # --- Capability System Imports (The Heart of the New Architecture) ---
                    from .capabilities import IMnaContributor, IDcContributor, provides
                    
                    # --- Type Imports for Explicit Contracts ---
                    # Use TYPE_CHECKING to import DCAnalysisResults only for type analysis,
                    # preventing a circular import at runtime with analysis_tools.py.
                    if TYPE_CHECKING:
                        from ..analysis_tools import DCAnalysisResults
                    
                    
                    logger = logging.getLogger(__name__)
                    
                    
                    @register_component("Subcircuit")
                    class SubcircuitInstance(ComponentBase):
                        """
                        Represents a hierarchical subcircuit instance within a larger circuit.
                        
                        Acts as a proxy for a nested `Circuit` object, presenting pre-computed, cached
                        results to the parent circuit's analysis engines via its capability implementations.
                        """
                    
                        # --- Capability Implementations are Nested Here ---
                    
                        @provides(IMnaContributor)
                        class MnaContributor:
                            """
                            Provides the pre-computed, cached MNA stamp for the subcircuit.
                            """
                    
                            def get_mna_stamps(
                                self,
                                component: "SubcircuitInstance",
                                freq_hz_array: np.ndarray,
                                # This argument is part of the IMnaContributor protocol signature
                                # but is intentionally ignored here because a SubcircuitInstance's
                                # behavior is fully determined by its pre-computed cache.
                                all_evaluated_params: Dict[str, Quantity],
                            ) -> List[StampInfo]:
                                """
                                Returns the N-port Y-matrix stamp from the pre-computed cache.
                                """
                                assert (
                                    component.cached_y_parameters_ac is not None
                                ), f"FATAL: Subcircuit '{component.fqn}' AC Y-parameters cache was not populated before stamping. This indicates a failure in the simulation executive."
                    
                                num_freqs, _, _ = component.cached_y_parameters_ac.shape
                                assert num_freqs == len(
                                    freq_hz_array
                                ), f"Subcircuit '{component.fqn}' cache frequency count ({num_freqs}) mismatches sweep count ({len(freq_hz_array)})."
                    
                                admittance_matrix_qty = Quantity(
                                    component.cached_y_parameters_ac, component.ureg.siemens
                                )
                                return [(admittance_matrix_qty, component.sub_circuit_external_port_names_ordered)]
                    
                        @provides(IDcContributor)
                        class DcContributor:
                            """
                            Provides the pre-computed, cached DC behavior for the subcircuit.
                            """
                    
                            def get_dc_behavior(
                                self,
                                component: "SubcircuitInstance",
                                # This argument is part of the IDcContributor protocol but is ignored here.
                                all_dc_params: Dict[str, Quantity],
                            ) -> Tuple[DCBehaviorType, Optional[Quantity]]:
                                """
                                Returns the DC behavior of the subcircuit based on its cached results.
                    
                                This method's behavior is determined entirely by its pre-computed DC analysis.
                                It will **NEVER** return `DCBehaviorType.SHORT_CIRCUIT`. A subcircuit that behaves
                                as a DC short across some or all of its ports is correctly and completely
                                represented by its N-port DC admittance matrix. Therefore, this method will
                                always return `DCBehaviorType.ADMITTANCE` when a valid DC Y-matrix is available.
                                This explicit contract is critical for the correctness of the `DCAnalyzer`.
                    
                                The returned DC Y-matrix MAY BE SINGULAR. It is the explicit responsibility
                                of the consuming `DCAnalyzer` to handle this possibility robustly.
                                """
                                assert (
                                    component.cached_dc_analysis_results is not None
                                ), f"FATAL: Subcircuit '{component.fqn}' DC analysis results cache was not populated before its DC behavior was requested."
                    
                                # **ARCHITECTURAL CORRECTION:**
                                # The following line accesses the DC Y-matrix via a type-safe attribute on the
                                # `DCAnalysisResults` dataclass. This fulfills the "Explicit Contracts" mandate
                                # by replacing the previous brittle, "magic string"-based dictionary access.
                                y_ports_dc_qty = component.cached_dc_analysis_results.y_ports_dc
                    
                                if isinstance(y_ports_dc_qty, Quantity) and y_ports_dc_qty.check(
                                    component.ureg.siemens
                                ):
                                    return (DCBehaviorType.ADMITTANCE, y_ports_dc_qty)
                    
                                return (DCBehaviorType.OPEN_CIRCUIT, None)
                    
                        # --- Component's Own Declarations and __init__ Follow ---
                    
                        def __init__(
                            self,
                            instance_id: str,
                            parameter_manager: ParameterManager,
                            sub_circuit_object_ref: Circuit,
                            sub_circuit_external_port_names_ordered: List[str],
                            parent_hierarchical_id: str,
                            raw_ir_data: ParsedSubcircuitData,
                        ):
                            super().__init__(
                                instance_id=instance_id,
                                parameter_manager=parameter_manager,
                                parent_hierarchical_id=parent_hierarchical_id,
                                raw_ir_data=raw_ir_data,
                            )
                    
                            if not isinstance(raw_ir_data, ParsedSubcircuitData):
                                raise TypeError(
                                    f"SubcircuitInstance '{instance_id}' must receive a "
                                    "ParsedSubcircuitData object for its raw instance data."
                                )
                    
                            self.sub_circuit_object: Circuit = sub_circuit_object_ref
                            self.sub_circuit_external_port_names_ordered: List[
                                str
                            ] = sub_circuit_external_port_names_ordered
                    
                            self.cached_y_parameters_ac: Optional[np.ndarray] = None
                            # This attribute now holds a dedicated dataclass, not a raw dictionary,
                            # creating a robust, type-safe contract with the simulation executive.
                            self.cached_dc_analysis_results: Optional["DCAnalysisResults"] = None
                    
                            logger.debug(
                                f"SubcircuitInstance '{self.fqn}' initialized, referencing definition "
                                f"from '{self.sub_circuit_object.source_file_path}'."
                            )
                    
                        @classmethod
                        def declare_parameters(cls) -> Dict[str, str]:
                            """Subcircuits do not declare parameters; they are containers."""
                            return {}
                    
                        @classmethod
                        def declare_ports(cls) -> List[str | int]:
                            """Subcircuit ports are dynamically defined by their definition file."""
                            return []
                    
                        @classmethod
                        def declare_connectivity(cls) -> List[Tuple[str | int, str | int]]:
                            """Subcircuit connectivity is complex and handled by recursive analysis."""
                            return []
                    
                        def is_structurally_open(
                            self, resolved_constant_params: Dict[str, Quantity]
                        ) -> bool:
                            """
                            A subcircuit instance itself is never a simple structural open.
                            """
                            return False
            constants.py
                # --- Create file: src/rfsim_core/constants.py ---
                import logging
                from .units import ureg, Quantity
                
                logger = logging.getLogger(__name__)
                
                # --- Numerical Constants for Simulation ---
                
                #: Large finite admittance value used to numerically represent ideal shorts (e.g., R=0, C=inf, L=0 at F>=0)
                #: in the MNA matrix for F>0 calculations, or for DC-shorted AC ports in results mapping.
                #: Value: 1e12 Siemens (equivalent to 1 micro-ohm impedance).
                LARGE_ADMITTANCE_SIEMENS: float = 1.0e12 # Siemens
                
                #: Threshold for admittance values considered effectively zero during numerical checks.
                #: Used for future numerical stability improvements (e.g., identifying near-zero connections
                #: that might cause ill-conditioning but are not strictly structural opens).
                #: Not actively used for ideal classification in Phase 7.
                #: Value: 1e-18 Siemens (equivalent to 1 Tera-ohm impedance).
                ZERO_ADMITTANCE_THRESHOLD_SIEMENS: float = 1.0e-18 # Siemens
                
                # You could add physical constants here later if needed, e.g.:
                # SPEED_OF_LIGHT = Quantity(299792458.0, 'm/s')
                # VACUUM_PERMITTIVITY = Quantity(8.8541878128e-12, 'F/m')
                # VACUUM_PERMEABILITY = Quantity(1.25663706212e-6, 'N/A**2') # approx 4*pi*1e-7 H/m
                
                logger.debug("Defined core constants: LARGE_ADMITTANCE_SIEMENS, ZERO_ADMITTANCE_THRESHOLD_SIEMENS")
            data_structures.py
                # src/rfsim_core/data_structures.py
                import logging
                from dataclasses import dataclass, field
                from typing import Dict, List, Optional, TYPE_CHECKING
                from pathlib import Path
                
                # Required for forward references in type hints (e.g., 'ComponentBase')
                from __future__ import annotations
                
                logger = logging.getLogger(__name__)
                
                # Use TYPE_CHECKING to avoid circular imports for type hints at runtime.
                if TYPE_CHECKING:
                    from .parameters import ParameterManager
                    from .components.base import ComponentBase
                    from .parser.raw_data import ParsedCircuitNode
                
                
                @dataclass(frozen=True)
                class Net:
                    """
                    Represents an electrical node (net) in the final, synthesized circuit model.
                    This object is immutable after creation by the CircuitBuilder.
                    """
                    name: str
                    is_ground: bool = False
                    is_external: bool = False
                    # The 'index' field for MNA is intentionally omitted here. It is transient,
                    # context-dependent state that belongs to the MnaAssembler, not the
                    # fundamental circuit data model.
                
                    def __hash__(self):
                        return hash(self.name)
                
                    def __eq__(self, other):
                        if not isinstance(other, Net):
                            return NotImplemented
                        return self.name == other.name
                
                
                @dataclass(frozen=True)
                class Circuit:
                    """
                    Represents the final, synthesized hierarchical circuit model.
                
                    This object is the definitive, simulation-ready representation of the circuit,
                    produced by the CircuitBuilder from the parser's Intermediate Representation (IR).
                    It is a data container and holds no imperative logic.
                    """
                    name: str
                    hierarchical_id: str
                    source_file_path: Path
                    ground_net_name: str
                
                    # The collection of all nets/nodes in this circuit's scope.
                    nets: Dict[str, Net]
                
                    # The collection of simulation-ready component instances (R, L, C, SubcircuitInstance).
                    sim_components: Dict[str, ComponentBase]
                
                    # The external interface of this circuit. The key is the port name.
                    external_ports: Dict[str, Net]
                
                    # The single, global parameter manager for the entire simulation.
                    parameter_manager: ParameterManager
                
                    # A non-negotiable link back to the root of the raw IR tree that was used
                    # to synthesize this Circuit object. This is essential for validation and diagnostics.
                    raw_ir_root: ParsedCircuitNode
            errors.py
                # src/rfsim_core/errors.py
                import logging
                from typing import Any, Dict, Protocol
                
                logger = logging.getLogger(__name__)
                
                # --- User-Facing Exception Hierarchy ---
                
                class RFSimError(Exception):
                    """Base class for all custom, user-facing errors in RFSim Core."""
                    pass
                
                class CircuitBuildError(RFSimError):
                    """
                    Raised when the circuit construction process fails for any reason, from parsing
                    to parameter resolution. The message is a pre-formatted, user-friendly diagnostic report.
                    """
                    pass
                
                class SimulationRunError(RFSimError):
                    """
                    Raised when the simulation execution fails for any reason after a successful build,
                    such as a semantic validation error or a numerical issue.
                    The message is a pre-formatted, user-friendly diagnostic report.
                    """
                    pass
                
                
                # --- Diagnostic Protocol (The Explicit Contract) ---
                
                class Diagnosable(Protocol):
                    """
                    A protocol for exceptions that can generate their own rich diagnostic report.
                    This decouples error handlers from the specific types of exceptions they process.
                    """
                    def get_diagnostic_report(self) -> str:
                        """Generates a complete, user-friendly, multi-line report string."""
                        ...
                
                
                # --- Stateless Formatting Utility ---
                
                def format_diagnostic_report(
                    error_type: str,
                    details: str,
                    suggestion: str,
                    context: Dict[str, Any]
                ) -> str:
                    """
                    A stateless helper to format the final multi-line report string, ensuring a
                    consistent look and feel for all user-facing diagnostics.
                
                    Args:
                        error_type: The high-level category of the error (e.g., "Unresolved Symbol").
                        details: A detailed, potentially multi-line description of the problem.
                        suggestion: Actionable advice for the user to resolve the issue.
                        context: A dictionary of contextual information (FQN, file path, user input, etc.).
                
                    Returns:
                        A formatted, user-friendly diagnostic report string ready for display.
                    """
                    lines = [
                        "\n",
                        "================ RFSim Core: Actionable Diagnostic Report ================",
                        f"Error Type:     {error_type}",
                    ]
                    if fqn := context.get('fqn'):
                        lines.append(f"FQN:            {fqn}")
                    if source_file := context.get('source_file'):
                        lines.append(f"Source File:    {source_file}")
                    if user_input := context.get('user_input'):
                        lines.append(f"User Input:     '{user_input}'")
                    if frequency := context.get('frequency'):
                        lines.append(f"Frequency:      {frequency}")
                
                    lines.append("\nDetails:")
                    for line in details.splitlines():
                        lines.append(f"  {line}")
                
                    if suggestion:
                        lines.append("\nSuggestion:")
                        for line in suggestion.splitlines():
                            lines.append(f"  {line}")
                
                    lines.append("========================================================================")
                    return "\n".join(lines)
            log_config.py
                # --- src/rfsim_core/log_config.py ---
                import logging
                import sys
                
                def setup_logging(level=logging.INFO):
                    """ Configures basic logging to stdout. """
                    log_formatter = logging.Formatter(
                        "%(asctime)s [%(levelname)-5.5s] [%(name)s] %(message)s"
                    )
                    root_logger = logging.getLogger() # Get the root logger
                
                    # Clear existing handlers
                    for handler in root_logger.handlers[:]:
                        root_logger.removeHandler(handler)
                        handler.close()
                
                    console_handler = logging.StreamHandler(sys.stdout)
                    console_handler.setFormatter(log_formatter)
                    root_logger.setLevel(level)
                    root_logger.addHandler(console_handler)
                    logging.info("Logging configured.")
            parameters/
                __init__.py
                    # src/rfsim_core/parameters/__init__.py
                    from .exceptions import (
                        ParameterError,
                        ParameterDefinitionError,
                        ParameterScopeError,
                        ParameterSyntaxError,
                        CircularParameterDependencyError,
                    )
                    from .preprocessor import ExpressionPreprocessor
                    from parameters import ParameterManager, ParameterDefinition
                    
                    __all__ = [
                        # Exceptions
                        "ParameterError",
                        "ParameterDefinitionError",
                        "ParameterScopeError",
                        "ParameterSyntaxError",
                        "CircularParameterDependencyError",
                        # Core Classes
                        "ExpressionPreprocessor",
                        "ParameterManager",
                        "ParameterDefinition",
                    ]
                exceptions.py
                    # src/rfsim_core/parameters/exceptions.py
                    from dataclasses import dataclass
                    from pathlib import Path
                    from typing import List, Dict, Any, Optional
                    
                    import numpy as np
                    
                    from ..errors import Diagnosable, format_diagnostic_report
                    
                    
                    class ParameterError(ValueError):
                        """Base class for all parameter-related errors."""
                        pass
                    
                    
                    @dataclass(frozen=True)
                    class ParameterDefinitionError(ParameterError, Diagnosable):
                        """Error during the definition or parsing of a single parameter."""
                        fqn: str
                        user_input: str
                        source_yaml_path: Path
                        details: str
                    
                        def __str__(self):
                            return f"Parameter '{self.fqn}': {self.details} (input: '{self.user_input}', file: '{self.source_yaml_path}')"
                    
                        def get_diagnostic_report(self) -> str:
                            return format_diagnostic_report(
                                error_type="Invalid Parameter Definition",
                                details=self.details,
                                suggestion="Ensure the parameter value has a valid syntax and its units are correct.",
                                context={
                                    'fqn': self.fqn,
                                    'source_file': self.source_yaml_path,
                                    'user_input': self.user_input,
                                }
                            )
                    
                    
                    @dataclass(frozen=True)
                    class ParameterScopeError(ParameterError, Diagnosable):
                        """Raised when a symbol cannot be resolved in its scope."""
                        owner_fqn: str
                        unresolved_symbol: str
                        user_input: str
                        source_yaml_path: Path
                        resolution_path_details: str
                    
                        def __str__(self):
                            return f"Unresolved symbol '{self.unresolved_symbol}' in expression for '{self.owner_fqn}' ('{self.user_input}')"
                    
                        def get_diagnostic_report(self) -> str:
                            main_details = f"The symbol '{self.unresolved_symbol}' could not be resolved within the scope of parameter '{self.owner_fqn}'.\n\n{self.resolution_path_details}"
                            return format_diagnostic_report(
                                error_type="Unresolved Symbol in Expression",
                                details=main_details,
                                suggestion="Check the spelling of the symbol or define it in an accessible scope (e.g., in the 'parameters' block of the relevant YAML file).",
                                context={
                                    'fqn': self.owner_fqn,
                                    'source_file': self.source_yaml_path,
                                    'user_input': self.user_input,
                                }
                            )
                    
                    
                    @dataclass(frozen=True)
                    class ParameterSyntaxError(ParameterError, Diagnosable):
                        """Raised for invalid syntax in a parameter expression."""
                        owner_fqn: str
                        user_input: str
                        source_yaml_path: Path
                        details: str
                    
                        def __str__(self):
                            return f"Invalid syntax for parameter '{self.owner_fqn}' ('{self.user_input}'): {self.details}"
                    
                        def get_diagnostic_report(self) -> str:
                            return format_diagnostic_report(
                                error_type="Invalid Expression Syntax",
                                details=self.details,
                                suggestion="Correct the syntax of the expression.",
                                context={
                                    'fqn': self.owner_fqn,
                                    'source_file': self.source_yaml_path,
                                    'user_input': self.user_input,
                                }
                            )
                    
                    
                    @dataclass(frozen=True)
                    class CircularParameterDependencyError(ParameterError, Diagnosable):
                        """Raised when a circular dependency is detected."""
                        cycle: List[str]
                    
                        def __str__(self):
                            cycle_display = self.cycle + [self.cycle[0]] if self.cycle and self.cycle[0] != self.cycle[-1] else self.cycle
                            return f"Circular dependency detected: {' -> '.join(cycle_display)}"
                    
                        def get_diagnostic_report(self) -> str:
                            return format_diagnostic_report(
                                error_type="Circular Parameter Dependency",
                                details=f"A circular reference was detected involving the following parameters:\n{' -> '.join(self.cycle)}",
                                suggestion="Break the dependency cycle by redefining one of the parameters to not depend on the others in the loop.",
                                context={'fqn': self.cycle[0]}
                            )
                    
                    
                    @dataclass(frozen=True)
                    class ParameterEvaluationError(ParameterError, Diagnosable):
                        """Raised when a runtime error occurs during parameter expression evaluation."""
                        fqn: str
                        details: str
                        error_indices: Optional[np.ndarray]
                        frequencies: Optional[np.ndarray]
                        input_values: Dict[str, Any]
                    
                        def __str__(self):
                            freq_str = f" at frequency {self.frequencies[0]:.4e} Hz" if self.frequencies is not None and len(self.frequencies) > 0 else ""
                            return f"Evaluation error for '{self.fqn}'{freq_str}: {self.details}"
                    
                        def get_diagnostic_report(self) -> str:
                            if self.error_indices is not None and self.frequencies is not None and self.error_indices.size > 0:
                                first_fail_idx = self.error_indices[0]
                                first_fail_freq = self.frequencies[first_fail_idx]
                                input_vals_at_first_failure = {
                                    name: val[first_fail_idx] if isinstance(val, np.ndarray) and val.ndim > 0 else val
                                    for name, val in self.input_values.items()
                                }
                                input_details = "\n".join(f"  - {name} = {val}" for name, val in input_vals_at_first_failure.items())
                                
                                details_str = (
                                    f"{self.details}\n\n"
                                    f"The error first occurred at index {first_fail_idx} (frequency = {first_fail_freq:.4e} Hz) "
                                    f"with the following input values:\n{input_details}"
                                )
                                if self.error_indices.size > 1:
                                    details_str += f"\n\nNote: This error occurred at {self.error_indices.size} total frequency points."
                            else:
                                details_str = self.details
                                
                            return format_diagnostic_report(
                                error_type="Parameter Evaluation Error",
                                details=details_str,
                                suggestion="Check the expression for operations that may be invalid at the given frequency (e.g., division by zero, logarithms of non-positive numbers).",
                                context={'fqn': self.fqn}
                            )
                parameters.py
                    # src/rfsim_core/parameters/parameters.py
                    import logging
                    from typing import Dict, Any, Set, Optional, List, Callable, Tuple, ChainMap
                    from dataclasses import dataclass
                    from pathlib import Path
                    
                    import pint
                    import sympy
                    from sympy import (
                        Symbol, Integer, Float, Rational, Add, Mul, Pow, I, Function,
                        Abs, sqrt, log, exp,
                        sin, cos, tan, asin, acos, atan, atan2,
                        re, im, arg, conjugate, Expr, pi
                    )
                    from sympy.core.relational import Relational
                    from sympy.logic.boolalg import BooleanFunction
                    from sympy import Derivative, Integral, Lambda, Piecewise
                    
                    import networkx as nx
                    import numpy as np
                    
                    from ..units import ureg, Quantity
                    from .preprocessor import ExpressionPreprocessor
                    from .exceptions import (
                        ParameterError, ParameterDefinitionError, ParameterScopeError,
                        ParameterSyntaxError, CircularParameterDependencyError, ParameterEvaluationError
                    )
                    
                    logger = logging.getLogger(__name__)
                    
                    
                    @dataclass(frozen=True)
                    class ParameterDefinition:
                        """
                        The explicit contract object representing a single parameter's definition.
                        It contains all necessary context for the ParameterManager's build process.
                        """
                        owner_fqn: str
                        base_name: str
                        raw_value_or_expression_str: str
                        source_yaml_path: Path
                        declared_dimension_str: str
                        is_sweepable: bool = False
                    
                        @property
                        def fqn(self) -> str:
                            """The canonical, fully qualified name (FQN) of the parameter."""
                            return f"{self.owner_fqn}.{self.base_name}"
                    
                    
                    class ParameterManager:
                        """
                        Manages all circuit parameters, their dependencies, and their evaluation.
                    
                        The manager is built once from a complete list of `ParameterDefinition` objects.
                        Its build process performs a one-time, definitive topological sort of the
                        dependency graph, producing a static evaluation order.
                    
                        The primary evaluation method, `evaluate_all`, leverages this static order to
                        efficiently compute all parameter values for a given frequency sweep in a single,
                        non-recursive, vectorized pass, returning a dictionary of vectorized `pint.Quantity` objects.
                        """
                        GLOBAL_SCOPE_PREFIX = "_rfsim_global_"
                    
                        def log10(x):
                            return log(x, 10)
                    
                        ALLOWED_SYMPY_FUNCTIONS = {
                            Abs, sqrt, log, exp, log10,
                            sin, cos, tan, asin, acos, atan, atan2,
                            re, im, arg, conjugate,
                        }
                        ALLOWED_SYMPY_SYMBOLS = {sympy.pi, sympy.E, sympy.I}
                        RESERVED_KEYWORDS = {'freq'}
                    
                        _PARSE_GLOBALS = {
                            "Symbol": Symbol, "Integer": Integer, "Float": Float, "Rational": Rational,
                            "Add": Add, "Mul": Mul, "Pow": Pow, "I": I, "Function": Function,
                            "pi": sympy.pi, "E": sympy.E,
                            **{func.__name__: func for func in ALLOWED_SYMPY_FUNCTIONS}
                        }
                    
                        def __init__(self):
                            self._ureg = ureg
                            self._parameter_context_map: Dict[str, Dict[str, Any]] = {}
                            self._dependency_graph = nx.DiGraph()
                            self._build_complete = False
                            self._parsed_constants: Dict[str, Quantity] = {}
                            self._compiled_functions: Dict[str, Callable] = {}
                            self._evaluation_order: List[str] = []
                            logger.info("ParameterManager initialized (empty).")
                    
                        def build(self, all_definitions: List[ParameterDefinition], scope_maps: Dict[str, ChainMap]):
                            if self._build_complete:
                                logger.warning("ParameterManager.build() called again. Rebuilding.")
                                self._clear_build_state()
                    
                            if not all_definitions:
                                logger.info("No parameter definitions provided. Build complete (empty).")
                                self._build_complete = True
                                return
                    
                            logger.info("Building ParameterManager context and dependency graph...")
                            try:
                                self._create_context_map_from_definitions(all_definitions)
                                self._parse_all_values_and_find_deps(scope_maps)
                                self._build_dependency_graph()
                                self._check_circular_dependencies()
                                self._compute_evaluation_order()
                                self._validate_and_compile_all_expressions()
                                self._evaluate_and_cache_all_constants()
                            except ParameterError as e:
                                logger.error(f"ParameterManager build failed: {e}", exc_info=False)
                                self._clear_build_state()
                                raise
                            except Exception as e:
                                logger.error(f"Unexpected error during ParameterManager build: {e}", exc_info=True)
                                self._clear_build_state()
                                raise ParameterError(f"Unexpected error during build: {e}") from e
                    
                            self._build_complete = True
                            logger.info(f"ParameterManager build complete. Defined parameters: {len(self._parameter_context_map)}.")
                    
                        def evaluate_all(self, freq_hz: np.ndarray) -> Dict[str, Quantity]:
                            """
                            Evaluates all parameters for a given frequency array in a single, non-recursive pass.
                            This is the primary method for obtaining parameter values for simulation.
                            """
                            self._check_build_complete()
                            results: Dict[str, Quantity] = {}
                    
                            for fqn in self._evaluation_order:
                                if fqn == 'freq': continue
                                context_info = self._parameter_context_map[fqn]
                    
                                if self.is_constant(fqn):
                                    const_qty = self._parsed_constants[fqn]
                                    mag = const_qty.magnitude
                                    if not isinstance(mag, np.ndarray) or mag.shape != freq_hz.shape:
                                        broadcasted_mag = np.full_like(freq_hz, mag, dtype=np.result_type(mag, float))
                                        results[fqn] = Quantity(broadcasted_mag, const_qty.units)
                                    else:
                                        results[fqn] = const_qty
                                    continue
                    
                                compiled_func = self._compiled_functions[fqn]
                                sympy_expr = context_info['sympy_expr']
                                
                                arg_fqns = sorted([str(s) for s in sympy_expr.free_symbols if s not in self.ALLOWED_SYMPY_SYMBOLS], key=str)
                                arg_values = [
                                    freq_hz if arg == 'freq' else results[arg].magnitude
                                    for arg in arg_fqns
                                ]
                    
                                try:
                                    numerical_result = compiled_func(*arg_values)
                                    if not isinstance(numerical_result, np.ndarray):
                                        numerical_result = np.full_like(freq_hz, numerical_result, dtype=float)
                                    
                                    non_finite_indices = np.where(~np.isfinite(numerical_result))[0]
                                    if non_finite_indices.size > 0:
                                        raise ValueError(f"Result contains non-finite values (NaN or inf).")
                    
                                    results[fqn] = Quantity(numerical_result, context_info['definition'].declared_dimension_str)
                    
                                except Exception as e:
                                    bad_indices = locals().get('non_finite_indices', None)
                                    input_values_for_error = {name: val for name, val in zip(arg_fqns, arg_values)}
                                    raise ParameterEvaluationError(
                                        fqn=fqn, details=str(e),
                                        error_indices=bad_indices,
                                        frequencies=freq_hz,
                                        input_values=input_values_for_error
                                    ) from e
                            
                            return results
                    
                        def get_external_dependencies_of_scope(self, fqns_in_scope: Set[str]) -> Tuple[Set[str], Set[str]]:
                            """
                            Analyzes the dependency graph to find all external parameters a given scope depends on.
                            
                            Args:
                                fqns_in_scope: A set of FQNs that define the boundary of the scope.
                    
                            Returns:
                                A tuple containing two sets:
                                - The FQNs of all CONSTANT external parameters the scope depends on.
                                - The FQNs of all FREQUENCY-DEPENDENT external parameters the scope depends on.
                            """
                            self._check_build_complete()
                            all_dependencies = set()
                            for internal_fqn in fqns_in_scope:
                                if internal_fqn in self._dependency_graph:
                                    # Find all parameters that internal_fqn depends on (ancestors in graph).
                                    all_dependencies.update(nx.ancestors(self._dependency_graph, internal_fqn))
                            
                            external_deps_fqns = {dep for dep in all_dependencies if dep not in fqns_in_scope and dep != 'freq'}
                            
                            const_ext_deps = {fqn for fqn in external_deps_fqns if self.is_constant(fqn)}
                            freq_ext_deps = external_deps_fqns - const_ext_deps
                            
                            return const_ext_deps, freq_ext_deps
                    
                        def _clear_build_state(self):
                            self._parameter_context_map = {}
                            self._dependency_graph = nx.DiGraph()
                            self._parsed_constants = {}
                            self._compiled_functions = {}
                            self._evaluation_order = []
                            self._build_complete = False
                    
                        def _create_context_map_from_definitions(self, all_definitions: List[ParameterDefinition]):
                            for definition in all_definitions:
                                fqn = definition.fqn
                                if fqn in self._parameter_context_map:
                                    raise ParameterDefinitionError(fqn=fqn, user_input=definition.raw_value_or_expression_str, source_yaml_path=definition.source_yaml_path, details=f"Duplicate parameter FQN '{fqn}' detected.")
                                self._parameter_context_map[fqn] = {'definition': definition, 'dependencies': set(), 'sympy_expr': None}
                    
                        def _parse_all_values_and_find_deps(self, scope_maps: Dict[str, ChainMap]):
                            preprocessor = ExpressionPreprocessor()
                            for fqn, context_info in self._parameter_context_map.items():
                                definition = context_info['definition']
                                raw_value = definition.raw_value_or_expression_str
                                
                                try:
                                    if self._try_parse_literal_quantity_string(raw_value) is not None:
                                        continue
                                except (pint.UndefinedUnitError, pint.DimensionalityError, TypeError, ValueError):
                                    pass
                    
                                scope = scope_maps.get(fqn)
                                if scope is None: raise ParameterError(f"Internal Error: No scope map provided for parameter '{fqn}'.")
                                
                                sympy_expr = preprocessor.preprocess(definition, scope, self.RESERVED_KEYWORDS)
                                context_info['sympy_expr'] = sympy_expr
                                dependencies = {str(s) for s in sympy_expr.free_symbols if s not in self.ALLOWED_SYMPY_SYMBOLS}
                                context_info['dependencies'] = dependencies
                    
                        def _build_dependency_graph(self):
                            self._dependency_graph.add_nodes_from(self._parameter_context_map.keys())
                            if any('freq' in ctx['dependencies'] for ctx in self._parameter_context_map.values()):
                                self._dependency_graph.add_node('freq')
                    
                            for fqn, ctx_info in self._parameter_context_map.items():
                                for dep_fqn in ctx_info['dependencies']:
                                    if not self._dependency_graph.has_node(dep_fqn):
                                        raise ParameterScopeError(owner_fqn=fqn, unresolved_symbol=dep_fqn, user_input=ctx_info['definition'].raw_value_or_expression_str, source_yaml_path=ctx_info['definition'].source_yaml_path, resolution_path_details="Dependency was not found in graph.")
                                    self._dependency_graph.add_edge(dep_fqn, fqn) # Edge from dependency TO dependent
                    
                        def _check_circular_dependencies(self):
                            try:
                                cycles = list(nx.simple_cycles(self._dependency_graph))
                                if cycles:
                                    raise CircularParameterDependencyError(cycle=cycles[0])
                            except nx.NetworkXError as e:
                                raise ParameterError(f"NetworkX error during cycle check: {e}") from e
                    
                        def _compute_evaluation_order(self):
                            # Topological sort gives an ordering where each node comes before all nodes it points to.
                            # Since our edges go from dependency -> dependent, this order is correct for evaluation.
                            self._evaluation_order = list(nx.topological_sort(self._dependency_graph))
                    
                        def _validate_and_compile_all_expressions(self):
                            for fqn, ctx in self._parameter_context_map.items():
                                if (sympy_expr := ctx.get('sympy_expr')) is not None:
                                    self._validate_expression_subset(fqn, sympy_expr)
                                    free_symbols = sorted(list(sympy_expr.free_symbols), key=str)
                                    ctx['compiled_func'] = sympy.lambdify(free_symbols, sympy_expr, modules=['numpy'], cse=True)
                                    self._compiled_functions[fqn] = ctx['compiled_func']
                    
                        def _evaluate_and_cache_all_constants(self):
                            logger.debug("Pre-evaluating and caching all constant parameters...")
                            constant_results: Dict[str, Quantity] = {}
                            for fqn in self._evaluation_order:
                                if self.is_constant(fqn):
                                    ctx = self._parameter_context_map[fqn]
                                    if (compiled_func := ctx.get('compiled_func')) is not None:
                                        arg_fqns = sorted([str(s) for s in ctx['sympy_expr'].free_symbols if s not in self.ALLOWED_SYMPY_SYMBOLS], key=str)
                                        arg_values = [constant_results[arg].magnitude for arg in arg_fqns]
                                        numerical_result = compiled_func(*arg_values)
                                        constant_results[fqn] = Quantity(numerical_result, ctx['definition'].declared_dimension_str)
                                    else:
                                        literal_val = self._try_parse_literal_quantity_string(ctx['definition'].raw_value_or_expression_str)
                                        constant_results[fqn] = literal_val
                            self._parsed_constants = constant_results
                            logger.debug(f"Cached {len(self._parsed_constants)} constant parameter values.")
                    
                        def _validate_expression_subset(self, fqn: str, sympy_expr: Expr):
                            expr_str = self._parameter_context_map[fqn]['definition'].raw_value_or_expression_str
                            definition = self._parameter_context_map[fqn]['definition']
                            for node in sympy.preorder_traversal(sympy_expr):
                                if isinstance(node, (Relational, BooleanFunction, Derivative, Integral, Lambda, Piecewise)):
                                    raise ParameterSyntaxError(owner_fqn=fqn, user_input=expr_str, source_yaml_path=definition.source_yaml_path, details=f"Disallowed operation type '{type(node).__name__}'.")
                                if node.is_Function and node.func not in self.ALLOWED_SYMPY_FUNCTIONS:
                                    raise ParameterSyntaxError(owner_fqn=fqn, user_input=expr_str, source_yaml_path=definition.source_yaml_path, details=f"Disallowed function '{node.func.__name__}'.")
                    
                        def _try_parse_literal_quantity_string(self, value_str: str) -> Optional[Quantity]:
                            try: return self._ureg.Quantity(value_str)
                            except (pint.UndefinedUnitError, pint.DimensionalityError, TypeError, ValueError): return None
                    
                        def _check_build_complete(self):
                            if not self._build_complete:
                                raise ParameterError("ParameterManager has not been built.")
                    
                        def get_all_fqn_definitions(self) -> List[ParameterDefinition]:
                            self._check_build_complete()
                            return [ctx['definition'] for ctx in self._parameter_context_map.values()]
                    
                        def get_parameter_definition(self, fqn: str) -> ParameterDefinition:
                            self._check_build_complete()
                            try:
                                return self._parameter_context_map[fqn]['definition']
                            except KeyError:
                                raise ParameterScopeError(owner_fqn="<lookup>", unresolved_symbol=fqn, user_input="", source_yaml_path=Path(), resolution_path_details=f"FQN '{fqn}' not found in parameter map.")
                    
                        def is_constant(self, fqn: str) -> bool:
                            self._check_build_complete()
                            if fqn == 'freq': return False
                            # A parameter is constant if 'freq' is not one of its ancestors in the dependency graph.
                            return 'freq' not in nx.ancestors(self._dependency_graph, fqn)
                    
                        def get_constant_value(self, fqn: str) -> Quantity:
                            self._check_build_complete()
                            if not self.is_constant(fqn):
                                raise ParameterError(f"Parameter '{fqn}' is not a constant value (it depends on 'freq').")
                            try:
                                return self._parsed_constants[fqn]
                            except KeyError:
                                raise ParameterError(f"Internal Error: Constant '{fqn}' was not found in the pre-evaluation cache.") from None
                preprocessor.py
                    # src/rfsim_core/parameters/preprocessor.py
                    import ast
                    import logging
                    from collections import ChainMap
                    from pathlib import Path
                    from typing import Set, Dict, TYPE_CHECKING
                    
                    import sympy
                    
                    from . import exceptions as param_exc
                    
                    # Use TYPE_CHECKING to import types for static analysis without creating
                    # a circular dependency at runtime.
                    if TYPE_CHECKING:
                        from parameters import ParameterDefinition
                    
                    logger = logging.getLogger(__name__)
                    
                    
                    class _IdentifierResolver(ast.NodeVisitor):
                        """
                        AST visitor to resolve all identifiers in an expression to their FQNs.
                        It carries full context to generate rich, diagnosable errors.
                        """
                        def __init__(
                            self,
                            owner_fqn: str,
                            raw_expr: str,
                            source_path: Path,
                            scope: ChainMap,
                            reserved_keywords: Set[str]
                        ):
                            self.owner_fqn = owner_fqn
                            self.raw_expr = raw_expr
                            self.source_path = source_path
                            self.scope = scope
                            self.reserved_keywords = reserved_keywords
                            self.symbol_map: Dict[str, str] = {}
                    
                        def _resolve_attribute_chain(self, node: ast.Attribute) -> str:
                            """Recursively builds a dot-separated string from an Attribute chain."""
                            parts = []
                            curr = node
                            while isinstance(curr, ast.Attribute):
                                parts.append(curr.attr)
                                curr = curr.value
                            if isinstance(curr, ast.Name):
                                parts.append(curr.id)
                                return ".".join(reversed(parts))
                            else:
                                source_segment = ast.get_source_segment(node) or "a complex expression"
                                raise param_exc.ParameterSyntaxError(
                                    owner_fqn=self.owner_fqn,
                                    user_input=self.raw_expr,
                                    source_yaml_path=self.source_path,
                                    details=f"Unsupported expression structure: attribute access on a non-identifier part: '{source_segment}'."
                                )
                    
                        def _generate_resolution_path_details(self, symbol: str) -> str:
                            """Creates the detailed diagnostic string for a failed lookup."""
                            lines = ["Resolution Path Searched:"]
                            for i, mapping in enumerate(self.scope.maps):
                                scope_name = f"Scope {i}"  # Generic name
                                if i == 0:
                                    scope_name = f"Local Scope for '{self.owner_fqn}'"
                                elif i == 1:
                                    # This is a heuristic; assumes the first non-local scope is the parent.
                                    scope_name = "Parent Scope"
                                
                                # Check if symbol is in the current map without triggering the ChainMap lookup
                                if symbol in mapping:
                                     lines.append(f"- {scope_name}: '{symbol}' FOUND.")
                                     break
                                else:
                                     lines.append(f"- {scope_name}: '{symbol}' not found.")
                            return "\n".join(lines)
                    
                        def visit_Attribute(self, node: ast.Attribute):
                            """Handles qualified identifiers like 'amp1.R1.resistance'."""
                            fqn_candidate = self._resolve_attribute_chain(node)
                            if fqn_candidate in self.scope:
                                resolved_fqn = self.scope[fqn_candidate]
                                if fqn_candidate not in self.symbol_map:
                                    self.symbol_map[fqn_candidate] = resolved_fqn
                            else:
                                raise param_exc.ParameterScopeError(
                                    owner_fqn=self.owner_fqn,
                                    unresolved_symbol=fqn_candidate,
                                    user_input=self.raw_expr,
                                    source_yaml_path=self.source_path,
                                    resolution_path_details=self._generate_resolution_path_details(fqn_candidate)
                                )
                            # We do NOT call generic_visit, as we have consumed the entire attribute chain.
                    
                        def visit_Name(self, node: ast.Name):
                            """
                            Handles standalone identifiers like 'gain'. This is only called for names
                            not part of an attribute chain, as visit_Attribute consumes those.
                            """
                            name = node.id
                            if name in self.reserved_keywords:
                                if name not in self.symbol_map:
                                    self.symbol_map[name] = name
                                return
                    
                            if name in self.scope:
                                if name not in self.symbol_map:
                                    self.symbol_map[name] = self.scope[name]
                            else:
                                # Inline import is a pragmatic choice to break the circular dependency
                                # between ParameterManager and ExpressionPreprocessor at runtime.
                                from parameters import ParameterManager
                                if name not in ParameterManager._PARSE_GLOBALS:
                                    raise param_exc.ParameterScopeError(
                                        owner_fqn=self.owner_fqn,
                                        unresolved_symbol=name,
                                        user_input=self.raw_expr,
                                        source_yaml_path=self.source_path,
                                        resolution_path_details=self._generate_resolution_path_details(name)
                                    )
                    
                    class ExpressionPreprocessor:
                        """
                        Implements the architectural mandate for robust, FQN-based expression handling.
                        It parses an expression string, resolves all identifiers to their canonical
                        Fully Qualified Names (FQNs), and produces a SymPy expression where all free
                        symbols are guaranteed to be these FQNs or reserved keywords.
                        """
                    
                        def preprocess(
                            self,
                            definition: 'ParameterDefinition',
                            scope: ChainMap,
                            reserved_keywords: Set[str]
                        ) -> sympy.Expr:
                            """
                            Transforms a string expression into a SymPy expression with fully-qualified symbols.
                    
                            Args:
                                definition: The full ParameterDefinition object, providing all necessary context.
                                scope: The lexical scope (ChainMap) for resolving identifiers.
                                reserved_keywords: Keywords like 'freq' that are not parameters.
                    
                            Returns:
                                A `sympy.Expr` object where all free symbols are FQNs or reserved keywords.
                            """
                            try:
                                tree = ast.parse(definition.raw_value_or_expression_str, mode='eval')
                            except SyntaxError as e:
                                raise param_exc.ParameterSyntaxError(
                                    owner_fqn=definition.fqn,
                                    user_input=definition.raw_value_or_expression_str,
                                    source_yaml_path=definition.source_yaml_path,
                                    details=f"Invalid Python syntax: {e}"
                                ) from e
                    
                            resolver = _IdentifierResolver(
                                owner_fqn=definition.fqn,
                                raw_expr=definition.raw_value_or_expression_str,
                                source_path=definition.source_yaml_path,
                                scope=scope,
                                reserved_keywords=reserved_keywords
                            )
                            resolver.visit(tree.body)
                    
                            local_sympy_dict = {
                                orig_name: sympy.Symbol(fqn)
                                for orig_name, fqn in resolver.symbol_map.items()
                            }
                    
                            try:
                                # Inline import is a pragmatic choice to break circular dependency.
                                from parameters import ParameterManager
                                sympy_expr = sympy.parse_expr(
                                    definition.raw_value_or_expression_str,
                                    local_dict=local_sympy_dict,
                                    global_dict=ParameterManager._PARSE_GLOBALS,
                                    evaluate=False
                                )
                                return sympy_expr
                            except Exception as e:
                                raise param_exc.ParameterSyntaxError(
                                    owner_fqn=definition.fqn,
                                    user_input=definition.raw_value_or_expression_str,
                                    source_yaml_path=definition.source_yaml_path,
                                    details=f"Error creating SymPy expression: {e}"
                                ) from e
            parser/
                __init__.py
                    # src/rfsim_core/parser/__init__.py
                    from .raw_data import (
                        ParsedCircuitNode,
                        ParsedComponentData,
                        ParsedLeafComponentData,
                        ParsedSubcircuitData,
                    )
                    from .parser import NetlistParser
                    from .exceptions import ParsingError, SchemaValidationError
                    
                    __all__ = [
                        # IR Data Structures
                        "ParsedCircuitNode",
                        "ParsedComponentData",
                        "ParsedLeafComponentData",
                        "ParsedSubcircuitData",
                        # Parser and Exceptions
                        "NetlistParser",
                        "ParsingError",
                        "SchemaValidationError",
                    ]
                exceptions.py
                    # src/rfsim_core/parser/exceptions.py
                    from dataclasses import dataclass
                    from pathlib import Path
                    from typing import Dict, Any
                    
                    from ..errors import Diagnosable, format_diagnostic_report
                    
                    class BaseParsingError(ValueError):
                        """Base class for parsing and schema validation errors."""
                        pass
                    
                    @dataclass(frozen=True)
                    class ParsingError(BaseParsingError, Diagnosable):
                        """Custom exception for logical errors or file issues during parsing."""
                        details: str
                        file_path: Path
                    
                        def __str__(self):
                            return f"Parsing error in file '{self.file_path}': {self.details}"
                    
                        def get_diagnostic_report(self) -> str:
                            return format_diagnostic_report(
                                error_type="YAML Parsing or File Error",
                                details=self.details,
                                suggestion="Ensure the file exists, has correct permissions, and contains valid YAML syntax.",
                                context={'source_file': self.file_path}
                            )
                    
                    @dataclass(frozen=True)
                    class SchemaValidationError(BaseParsingError, Diagnosable):
                        """Custom exception for YAML schema validation failures."""
                        errors: Dict[str, Any]
                        file_path: Path
                    
                        def __str__(self):
                            error_lines = [
                                f"  - In field '{'.'.join(map(str, k))}': {v[0]}"
                                for k, v in sorted(self.errors.items())
                            ]
                            return (
                                f"YAML schema validation failed for file '{self.file_path}':\n"
                                + "\n".join(error_lines)
                            )
                    
                        def get_diagnostic_report(self) -> str:
                            details = "The structure of the YAML file does not conform to the required schema.\nSee details below:\n" + "\n".join(
                                f"  - Field '{'.'.join(map(str, k))}': {v[0]}" for k, v in sorted(self.errors.items())
                            )
                            return format_diagnostic_report(
                                error_type="YAML Schema Validation Error",
                                details=details,
                                suggestion="Correct the specified fields in the YAML file to match the documented format.",
                                context={'source_file': self.file_path}
                            )
                parser.py
                    # src/rfsim_core/parser/parser.py
                    import logging
                    import re
                    import string
                    from pathlib import Path
                    from typing import Any, Dict, List, Set, Union
                    
                    import cerberus
                    import yaml
                    
                    from .raw_data import (
                        ParsedCircuitNode,
                        ParsedComponentData,
                        ParsedLeafComponentData,
                        ParsedSubcircuitData,
                    )
                    
                    logger = logging.getLogger(__name__)
                    
                    class SchemaValidationError(ValueError):
                        """
                        Custom exception raised when YAML does not conform to the schema.
                        Provides a rich, multi-line, deterministic error message for clear user feedback.
                        """
                        def __init__(self, errors: Dict, file_path: Path, *args):
                            self.errors = errors
                            error_lines = [
                                f"  - In field '{'.'.join(map(str, k))}': {v[0]}"
                                for k, v in sorted(errors.items())
                            ]
                            message = (
                                f"YAML schema validation failed for file '{file_path}':\n"
                                + "\n".join(error_lines)
                            )
                            super().__init__(message, *args)
                    
                    class ParsingError(ValueError):
                        """Custom exception for logical errors or file issues during parsing."""
                        pass
                    
                    # This regex enforces the "Simplicity Through Constraint" architectural mandate.
                    # It defines a valid identifier, explicitly forbidding '.' (FQN separator) and '-'
                    # (mathematical operator) to prevent ambiguity and simplify the system.
                    ID_REGEX = r"^[a-zA-Z_][a-zA-Z0-9_]*$"
                    ALLOWED_ID_CHARS = set(string.ascii_letters + string.digits + "_")
                    
                    # This more permissive regex allows dot-separated chains of valid identifiers.
                    # It is used exclusively for the keys in a subcircuit's 'parameters' override block.
                    PARAM_OVERRIDE_KEY_REGEX = f"^{ID_REGEX}(\\.{ID_REGEX})*$"
                    
                    class EnhancedValidator(cerberus.Validator):
                        """Custom Cerberus validator to enforce the project's strict naming conventions."""
                        def _validate_id_regex(self, constraint: bool, field: str, value: Any):
                            if not constraint: return
                            if not isinstance(value, str):
                                self._error(field, "must be a string to be validated by id_regex.")
                                return
                    
                            if not re.match(ID_REGEX, value):
                                invalid_chars = sorted(list(set(value) - ALLOWED_ID_CHARS))
                                message = (
                                    f"Identifier '{value}' is invalid. Identifiers must start with a letter or underscore, "
                                    "and can only contain letters, numbers, and underscores. The dot '.' and hyphen '-' characters are forbidden. "
                                    f"This identifier contains the following forbidden character(s): {invalid_chars}"
                                )
                                self._error(field, message)
                    
                        def _validate_param_override_key_regex(self, constraint: bool, field: str, value: str):
                            if constraint and isinstance(value, str) and not re.match(PARAM_OVERRIDE_KEY_REGEX, value):
                                self._error(
                                    field,
                                    f"Parameter override key '{value}' is invalid. Must be a valid identifier or a "
                                    f"dot-separated chain of valid identifiers (e.g., 'gain' or 'amp1.R_load.value').",
                                )
                    
                    class NetlistParser:
                        """
                        Recursively parses and validates a hierarchy of netlist YAML files.
                        Its sole responsibility is to produce a tree of Intermediate Representation (IR) objects.
                        """
                        _id_rule = {"type": "string", "required": True, "empty": False, "id_regex": True}
                        _net_name_rule = {"type": "string", "required": True, "empty": False, "id_regex": True}
                        _param_key_rule = {"type": "string", "required": True, "empty": False, "id_regex": True}
                        _param_override_key_rule = {"type": "string", "required": True, "empty": False, "param_override_key_regex": True}
                    
                        _param_value_schema = {
                            "oneof": [
                                {"type": ["string", "number"]},
                                {"type": "dict", "schema": {"expression": {"type": "string", "required": True}, "dimension": {"type": "string", "required": True}}},
                            ]
                        }
                    
                        _standard_component_schema = {
                            "type": {"type": "string", "required": True, "id_regex": True, "disallowed": ["Subcircuit"]},
                            "id": _id_rule,
                            "ports": {"type": "dict", "required": True, "minlength": 1, "keysrules": {"oneof": [{"type": "string", "id_regex": True}, {"type": "integer"}]}, "valuesrules": _net_name_rule},
                            "parameters": {"type": "dict", "required": False, "keysrules": _param_key_rule, "valuesrules": _param_value_schema},
                        }
                    
                        _subcircuit_component_schema = {
                            "type": {"type": "string", "required": True, "allowed": ["Subcircuit"]},
                            "id": _id_rule,
                            "definition_file": {"type": "string", "required": True, "empty": False},
                            "ports": {"type": "dict", "required": False, "minlength": 1, "keysrules": _param_key_rule, "valuesrules": _net_name_rule},
                            "parameters": {"type": "dict", "required": False, "keysrules": _param_override_key_rule, "valuesrules": _param_value_schema},
                        }
                    
                        _schema = {
                            "circuit_name": {"type": "string", "required": False, "id_regex": True},
                            "ground_net": {"type": "string", "required": False, "id_regex": True, "default": "gnd"},
                            "parameters": {"type": "dict", "required": False, "keysrules": _param_key_rule, "valuesrules": _param_value_schema},
                            "components": {"type": "list", "required": True, "minlength": 1, "unique": "id", "schema": {"type": "dict", "oneof_schema": [_standard_component_schema, _subcircuit_component_schema]}},
                            "ports": {"type": "list", "required": False, "unique": "id", "schema": {"type": "dict", "schema": {"id": _id_rule, "reference_impedance": {"type": "string", "required": True}}}},
                            "sweep": {
                                "type": "dict", "required": False, "schema": {
                                    "type": {"type": "string", "required": True, "allowed": ["linear", "log", "list"]},
                                    "start": {"type": "string", "required": True, "dependencies": {"type": ["linear", "log"]}},
                                    "stop": {"type": "string", "required": True, "dependencies": {"type": ["linear", "log"]}},
                                    "num_points": {"type": "integer", "required": True, "min": 1, "dependencies": {"type": ["linear", "log"]}},
                                    "points": {"type": "list", "required": True, "minlength": 1, "schema": {"type": ["string", "number"]}, "dependencies": {"type": ["list"]}},
                                },
                            },
                        }
                    
                        def __init__(self):
                            self._validator = EnhancedValidator(self._schema)
                            self._validator.allow_unknown = False
                            logger.info("NetlistParser initialized with strict structural validation rules.")
                    
                        def parse_to_circuit_tree(self, top_level_yaml_path: Union[str, Path]) -> ParsedCircuitNode:
                            """Parses the top-level YAML and all subcircuits, returning the complete IR tree."""
                            top_path = Path(top_level_yaml_path).resolve()
                            logger.info(f"Starting hierarchical parsing from top-level file: {top_path}")
                            return self._parse_recursive(top_path, visited_paths=set())
                    
                        def _parse_recursive(self, yaml_path: Path, visited_paths: Set[Path]) -> ParsedCircuitNode:
                            """Internal recursive function that parses one file and returns its IR node."""
                            resolved_path = yaml_path.resolve()
                            if resolved_path in visited_paths:
                                raise ParsingError(f"Circular subcircuit dependency detected involving: {resolved_path}")
                            
                            visited_paths.add(resolved_path)
                            logger.debug(f"Parsing definition file: {resolved_path}")
                    
                            yaml_content = self._load_yaml(resolved_path)
                            if not self._validator.validate(yaml_content):
                                raise SchemaValidationError(self._validator.errors, resolved_path)
                            
                            validated_data = self._validator.document
                    
                            parsed_components: List[ParsedComponentData] = []
                            for comp_data_raw in validated_data.get("components", []):
                                comp_id = comp_data_raw["id"]
                                if comp_data_raw["type"] == "Subcircuit":
                                    sub_def_file_path = (resolved_path.parent / comp_data_raw["definition_file"]).resolve()
                                    sub_node = self._parse_recursive(sub_def_file_path, visited_paths.copy())
                                    parsed_components.append(
                                        ParsedSubcircuitData(
                                            instance_id=comp_id,
                                            component_type="Subcircuit",
                                            definition_file_path=sub_def_file_path,
                                            sub_circuit_definition_node=sub_node,
                                            raw_port_mapping=comp_data_raw.get("ports", {}),
                                            raw_parameter_overrides=comp_data_raw.get("parameters", {}),
                                            source_yaml_path=resolved_path,
                                        )
                                    )
                                else:
                                    parsed_components.append(
                                        ParsedLeafComponentData(
                                            instance_id=comp_id,
                                            component_type=comp_data_raw["type"],
                                            raw_ports_dict=comp_data_raw["ports"],
                                            raw_parameters_dict=comp_data_raw.get("parameters", {}),
                                            source_yaml_path=resolved_path,
                                        )
                                    )
                    
                            return ParsedCircuitNode(
                                circuit_name=validated_data.get("circuit_name", resolved_path.stem),
                                ground_net_name=validated_data["ground_net"],
                                source_yaml_path=resolved_path,
                                components=parsed_components,
                                raw_parameters_dict=validated_data.get("parameters", {}),
                                raw_external_ports_list=validated_data.get("ports", []),
                                raw_sweep_config=validated_data.get("sweep"),
                            )
                    
                        def _load_yaml(self, source: Path) -> Dict[str, Any]:
                            """Loads and performs basic sanity checks on a YAML file."""
                            if not source.is_file():
                                raise FileNotFoundError(f"Netlist file not found: {source}")
                            try:
                                with source.open("r", encoding="utf-8") as f:
                                    content = yaml.safe_load(f)
                                if content is None:
                                    raise ParsingError(f"The YAML file '{source}' is empty or contains no valid content.")
                                if not isinstance(content, dict):
                                    raise ParsingError(f"The root of the YAML file '{source}' must be a dictionary (mapping).")
                                return content
                            except PermissionError as e:
                                raise ParsingError(f"Permission denied when trying to read '{source}': {e}") from e
                            except yaml.YAMLError as e:
                                raise ParsingError(f"Invalid YAML syntax in '{source}': {e}") from e
                raw_data.py
                    # src/rfsim_core/parser/raw_data.py
                    from __future__ import annotations
                    
                    from dataclasses import dataclass, field
                    from typing import Dict, Any, List, Optional, Union
                    from pathlib import Path
                    
                    # The classes in this module define the Intermediate Representation (IR).
                    # This IR establishes the formal, type-safe, non-negotiable contract between
                    # the NetlistParser and the CircuitBuilder. Using frozen dataclasses abolishes
                    # the use of raw dictionaries for passing structured data, which is a foundational
                    # tenet of the definitive architecture for correctness and maintainability.
                    
                    @dataclass(frozen=True)
                    class ParsedLeafComponentData:
                        """IR for a leaf-level component (e.g., R, L, C, or a future plugin component)."""
                        instance_id: str
                        component_type: str
                        raw_ports_dict: Dict[str | int, str]
                        raw_parameters_dict: Dict[str, Any]
                        source_yaml_path: Path
                    
                    @dataclass(frozen=True)
                    class ParsedSubcircuitData:
                        """IR for a subcircuit instance."""
                        instance_id: str
                        component_type: str  # Always "Subcircuit"
                        definition_file_path: Path
                        sub_circuit_definition_node: ParsedCircuitNode
                        raw_port_mapping: Dict[str, str]
                        raw_parameter_overrides: Dict[str, Any]
                        source_yaml_path: Path
                    
                    ParsedComponentData = Union[ParsedLeafComponentData, ParsedSubcircuitData]
                    
                    @dataclass(frozen=True)
                    class ParsedCircuitNode:
                        """
                        Top-level IR node representing a single parsed YAML file.
                        This forms a tree structure for hierarchical designs.
                        """
                        circuit_name: str
                        ground_net_name: str
                        source_yaml_path: Path
                        components: List[ParsedComponentData]
                        raw_parameters_dict: Dict[str, Any]
                        raw_external_ports_list: List[Dict[str, Any]]
                        raw_sweep_config: Optional[Dict[str, Any]] = None
            simulation/
                __init__.py
                    # src/rfsim_core/simulation/__init__.py
                    from .exceptions import (
                        MnaInputError,
                        ComponentError,
                        DCAnalysisError,
                        SingularMatrixError,
                        SingleLevelSimulationFailure,
                    )
                    from .mna import MnaAssembler
                    from .solver import solve_mna_system, factorize_mna_matrix
                    from .execution import run_simulation, run_sweep
                    
                    __all__ = [
                        # Exceptions
                        "MnaInputError",
                        "ComponentError",
                        "DCAnalysisError",
                        "SingularMatrixError",
                        "SingleLevelSimulationFailure",
                        # Core Classes
                        "MnaAssembler",
                        "solve_mna_system",
                        "factorize_mna_matrix",
                        "run_simulation",
                        "run_sweep",
                    ]
                config.py
                    # src/rfsim_core/simulation/config.py
                    import logging
                    import numpy as np
                    import pint
                    from typing import Dict, Any
                    
                    from ..units import ureg
                    
                    logger = logging.getLogger(__name__)
                    
                    class ConfigParsingError(ValueError):
                        """Custom exception for errors during simulation configuration parsing."""
                        pass
                    
                    def parse_sweep_config(raw_sweep_config: Dict[str, Any]) -> np.ndarray:
                        """
                        Parses a raw sweep configuration dictionary into a NumPy frequency array.
                        """
                        if not raw_sweep_config:
                            raise ConfigParsingError("Sweep configuration is missing or empty.")
                        try:
                            sweep_type = raw_sweep_config['type']
                            freq_values_hz = np.array([], dtype=float)
                    
                            if sweep_type in ['linear', 'log']:
                                start_hz = ureg.Quantity(raw_sweep_config['start']).to('Hz').magnitude
                                stop_hz = ureg.Quantity(raw_sweep_config['stop']).to('Hz').magnitude
                                num_points = int(raw_sweep_config['num_points'])
                                
                                if stop_hz < start_hz: raise ValueError("Stop frequency cannot be less than start frequency.")
                    
                                if sweep_type == 'linear':
                                    if start_hz < 0: raise ValueError("Linear sweep start frequency must be >= 0.")
                                    freq_values_hz = np.linspace(start_hz, stop_hz, num_points, dtype=float)
                                else: # log
                                    if start_hz <= 0 or stop_hz <= 0: raise ValueError("Log sweep frequencies must be > 0.")
                                    freq_values_hz = np.geomspace(start_hz, stop_hz, num_points, dtype=float)
                    
                            elif sweep_type == 'list':
                                points = [ureg.Quantity(p).to('Hz').magnitude for p in raw_sweep_config['points']]
                                if any(f < 0 for f in points): raise ValueError("Frequencies in list must be non-negative.")
                                freq_values_hz = np.array(sorted(list(set(points))), dtype=float)
                                
                            return freq_values_hz
                        except (KeyError, ValueError, pint.DimensionalityError, pint.UndefinedUnitError) as e:
                            raise ConfigParsingError(f"Failed to parse sweep configuration: {e}") from e
                exceptions.py
                    # src/rfsim_core/simulation/exceptions.py
                    import numpy as np
                    from typing import Optional, Any
                    from dataclasses import dataclass
                    from pathlib import Path
                    
                    from ..errors import Diagnosable, format_diagnostic_report
                    
                    @dataclass(frozen=True)
                    class MnaInputError(ValueError, Diagnosable):
                        """Error related to inputs for MNA assembly."""
                        hierarchical_context: str
                        details: str
                    
                        def get_diagnostic_report(self) -> str:
                            return format_diagnostic_report(
                                error_type="MNA Input Error",
                                details=self.details,
                                suggestion="This is often an internal error or a circuit topology that violates MNA rules (e.g., floating ports).",
                                context={'fqn': self.hierarchical_context}
                            )
                    
                    @dataclass(frozen=True)
                    class ComponentError(ValueError, Diagnosable):
                        """Custom exception for component-related errors during simulation."""
                        component_fqn: str
                        details: str
                        frequency: Optional[float] = None
                    
                        def get_diagnostic_report(self) -> str:
                            return format_diagnostic_report(
                                error_type="Component Simulation Error",
                                details=self.details,
                                suggestion="Check the component's parameters and ensure they are valid for the given frequency.",
                                context={'fqn': self.component_fqn, 'frequency': f"{self.frequency:.4e} Hz" if self.frequency is not None else "N/A"}
                            )
                    
                    @dataclass(frozen=True)
                    class DCAnalysisError(ValueError, Diagnosable):
                        """Custom exception for errors during rigorous DC analysis."""
                        hierarchical_context: str
                        details: str
                        
                        def get_diagnostic_report(self) -> str:
                            return format_diagnostic_report(
                                error_type="DC Analysis Error",
                                details=self.details,
                                suggestion="Review the circuit for issues with DC shorts (R=0, L=0) or opens (C=inf) that might create an invalid topology at F=0.",
                                context={'fqn': self.hierarchical_context}
                            )
                    
                    @dataclass(frozen=True)
                    class SingularMatrixError(np.linalg.LinAlgError, Diagnosable):
                        """Custom exception for singular matrix during factorization or solve."""
                        details: str
                        frequency: Optional[float] = None
                    
                        def __str__(self):
                            freq_str = f" at frequency {self.frequency:.4e} Hz" if self.frequency is not None else ""
                            return f"Singular matrix detected{freq_str}: {self.details}"
                    
                        def get_diagnostic_report(self) -> str:
                            return format_diagnostic_report(
                                error_type="Singular Matrix Encountered",
                                details=self.details,
                                suggestion="This is often caused by a floating sub-circuit or a shorted loop of ideal components at a specific frequency. Check your circuit topology and component values.",
                                context={'frequency': f"{self.frequency:.4e} Hz" if self.frequency else "N/A"}
                            )
                    
                    @dataclass(frozen=True)
                    class SingleLevelSimulationFailure(Exception, Diagnosable):
                        """
                        An internal, context-enriching exception that wraps a low-level diagnosable
                        error with the high-level hierarchical context in which it occurred.
                        """
                        circuit_fqn: str
                        circuit_source_path: Path
                        original_error: Diagnosable
                    
                        def get_diagnostic_report(self) -> str:
                            # Get the report from the original, low-level error
                            original_report = self.original_error.get_diagnostic_report()
                            
                            # Prepend the hierarchical context to the report
                            header = [
                                f"Error occurred within circuit context: '{self.circuit_fqn}'",
                                f"Defined in file: '{self.circuit_source_path}'",
                            ]
                            
                            # We slice the original report to remove its header and combine it with our new, richer one.
                            original_lines = original_report.strip().splitlines()
                            report_body = "\n".join(original_lines[2:]) # Skip the "===", "Error Type:"
                            
                            # Re-assemble the full report with the new, richer header
                            full_report_lines = [
                                "\n",
                                "================ RFSim Core: Actionable Diagnostic Report ================",
                            ] + header + [report_body] + [
                                "========================================================================"
                            ]
                            
                            return "\n".join(full_report_lines)
                execution.py
                    # src/rfsim_core/simulation/execution.py
                    import logging
                    import numpy as np
                    from typing import Tuple, Dict, Any, Optional, List, Set
                    import networkx as nx
                    
                    from .mna import MnaAssembler, StampInfo
                    from .solver import factorize_mna_matrix
                    from .exceptions import (
                        MnaInputError,
                        ComponentError,
                        DCAnalysisError,
                        SingularMatrixError,
                        SingleLevelSimulationFailure,
                    )
                    from ..data_structures import Circuit
                    from ..units import ureg
                    from ..components.subcircuit import SubcircuitInstance
                    
                    # --- BEGIN Phase 9 Task 5 Change ---
                    # NEW IMPORT: Import the IMnaContributor protocol.
                    # This import is the cornerstone of the decoupling. The execution engine now depends on
                    # an abstract interface (the Protocol), not a concrete component base class method. This
                    # fulfills the "Decoupling through Queryable Interfaces" mandate.
                    from ..components.capabilities import IMnaContributor
                    # --- END Phase 9 Task 5 Change ---
                    
                    from ..constants import LARGE_ADMITTANCE_SIEMENS
                    from ..analysis_tools import DCAnalyzer, TopologyAnalyzer
                    from ..parameters import ParameterManager, ParameterError
                    from ..validation import SemanticValidator
                    from ..validation.exceptions import SemanticValidationError
                    from ..errors import SimulationRunError, Diagnosable, format_diagnostic_report
                    
                    logger = logging.getLogger(__name__)
                    
                    
                    def run_simulation(circuit: Circuit, freq_hz: float) -> Tuple[np.ndarray, Optional[Dict[str, Any]]]:
                        freq_array = np.array([freq_hz], dtype=float)
                        _, y_matrices, dc_results = run_sweep(circuit, freq_array)
                        return y_matrices[0], dc_results
                    
                    
                    def run_sweep(
                        circuit: Circuit, freq_array_hz: np.ndarray
                    ) -> Tuple[np.ndarray, np.ndarray, Optional[Dict[str, Any]]]:
                        try:
                            if not isinstance(circuit, Circuit) or not circuit.parameter_manager:
                                raise ValueError("Input circuit object is not simulation-ready.")
                            
                            logger.info(f"--- Starting hierarchical frequency sweep for '{circuit.name}' ---")
                    
                            validator = SemanticValidator(circuit)
                            issues = validator.validate()
                            error_issues = [issue for issue in issues if issue.level == "ERROR"]
                            if error_issues:
                                raise SemanticValidationError(issues)
                            
                            simulation_cache: Dict[Tuple, Dict[str, Any]] = {}
                            _populate_subcircuit_caches_recursive(
                                circuit, freq_array_hz, circuit.parameter_manager, simulation_cache
                            )
                            
                            logger.info(f"--- All subcircuit caches populated. Simulating top-level circuit '{circuit.name}'... ---")
                            top_level_results = _run_single_level_simulation(circuit, freq_array_hz)
                            
                            logger.info(f"--- Hierarchical frequency sweep finished for '{circuit.name}' ---")
                            return (
                                top_level_results['frequencies_hz'],
                                top_level_results['y_matrices'],
                                top_level_results['dc_results'],
                            )
                    
                        except Diagnosable as e:
                            diagnostic_report = e.get_diagnostic_report()
                            raise SimulationRunError(diagnostic_report) from e
                        
                        except Exception as e:
                            report = format_diagnostic_report(
                                error_type=f"An Unexpected Simulation Error Occurred ({type(e).__name__})",
                                details=f"The simulator encountered an unexpected internal error: {str(e)}",
                                suggestion="This may be a bug. Review the traceback and consider filing a bug report.",
                                context={},
                            )
                            raise SimulationRunError(report) from e
                    
                    
                    def _populate_subcircuit_caches_recursive(
                        circuit_node: Circuit,
                        freq_array_hz: np.ndarray,
                        global_pm: ParameterManager,
                        simulation_cache: Dict[Tuple, Dict[str, Any]],
                    ):
                        for sim_comp in circuit_node.sim_components.values():
                            if isinstance(sim_comp, SubcircuitInstance):
                                _populate_subcircuit_caches_recursive(
                                    sim_comp.sub_circuit_object, freq_array_hz, global_pm, simulation_cache
                                )
                                
                                cache_key = _compute_subcircuit_cache_key(sim_comp, freq_array_hz, global_pm)
                                
                                if cache_key in simulation_cache:
                                    logger.info(f"Cache HIT for subcircuit instance '{sim_comp.fqn}'. Re-using results.")
                                    results = simulation_cache[cache_key]
                                else:
                                    logger.info(f"Cache MISS for '{sim_comp.fqn}'. Simulating definition '{sim_comp.sub_circuit_object.name}'.")
                                    results = _run_single_level_simulation(sim_comp.sub_circuit_object, freq_array_hz)
                                    simulation_cache[cache_key] = results
                                
                                sim_comp.cached_y_parameters_ac = results.get('y_matrices')
                                sim_comp.cached_dc_analysis_results = results.get('dc_results')
                    
                    
                    def _run_single_level_simulation(
                        circuit: Circuit, freq_array_hz: np.ndarray
                    ) -> Dict[str, Any]:
                        logger.info(f"--- Running single-level simulation for '{circuit.hierarchical_id}' ({len(freq_array_hz)} points) ---")
                        
                        try:
                            dc_analyzer = DCAnalyzer(circuit)
                            dc_analysis_results = dc_analyzer.analyze()
                    
                            topology_analyzer = TopologyAnalyzer(circuit)
                            active_nets_for_ac = topology_analyzer.get_active_nets()
                            
                            if circuit.external_ports:
                                if circuit.ground_net_name not in active_nets_for_ac:
                                    raise MnaInputError(hierarchical_context=circuit.hierarchical_id, details="Ground net is not part of the active AC circuit, but external ports exist.")
                                if not topology_analyzer.are_ports_connected_to_active_ground():
                                    raise MnaInputError(hierarchical_context=circuit.hierarchical_id, details="No conductive path exists between any active external port and the active ground net.")
                    
                            assembler = MnaAssembler(circuit, active_nets_override=active_nets_for_ac)
                            ac_port_names_ordered = assembler.port_names
                            num_ac_ports = len(ac_port_names_ordered)
                            y_matrices = np.full((len(freq_array_hz), num_ac_ports, num_ac_ports), np.nan + 0j, dtype=np.complex128)
                    
                            # --- BEGIN Phase 9 Task 5 Change: Refactored Vectorized Pre-computation Step ---
                            
                            # This step remains the same: all parameters are evaluated once for the entire sweep.
                            logger.debug(f"[{circuit.hierarchical_id}] Evaluating all parameters for the full frequency sweep...")
                            all_evaluated_params = circuit.parameter_manager.evaluate_all(freq_array_hz)
                            
                            logger.debug(f"[{circuit.hierarchical_id}] Pre-computing all vectorized MNA stamps via capabilities...")
                            all_stamps_vectorized: Dict[str, List[StampInfo]] = {}
                            
                            # This loop is the heart of the "CRITICAL CORRECTION". It iterates through the
                            # components ONCE, before the per-frequency loop, to gather all vectorized stamps.
                            for comp_fqn, sim_comp in assembler.effective_sim_components.items():
                                # STEP 1: Query for the capability.
                                # This is the decoupled query. We ask "Can you contribute to MNA?" instead
                                # of assuming `sim_comp.get_mna_stamps` exists.
                                mna_contributor = sim_comp.get_capability(IMnaContributor)
                                
                                if mna_contributor:
                                    # STEP 2: If the capability exists, call its method.
                                    # The call is wrapped in a try/except block to provide robust, contextual
                                    # diagnostics if a component's implementation fails.
                                    try:
                                        # The contract here is critical:
                                        #   - The `sim_comp` instance is passed as context.
                                        #   - The full `freq_array_hz` is passed.
                                        #   - The capability is expected to perform a single, vectorized calculation.
                                        # This fulfills the "Explicit and Vectorized Context Passing" mandate.
                                        stamps = mna_contributor.get_mna_stamps(
                                            sim_comp, freq_array_hz, all_evaluated_params
                                        )
                                        all_stamps_vectorized[comp_fqn] = stamps
                                    except Exception as e:
                                        # Wrap any failure in a diagnosable, contextual error. This provides
                                        # clear feedback to the user, pinpointing the failing component.
                                        raise ComponentError(component_fqn=comp_fqn, details=f"Failed during vectorized MNA stamp computation: {e}") from e
                                else:
                                    # STEP 3: If the capability does not exist, log it and move on.
                                    # This makes the system robust to components that are not MNA-aware (e.g.,
                                    # future non-electrical components). The assembler will correctly skip it as
                                    # its FQN will not be in the `all_stamps_vectorized` dictionary.
                                    logger.debug(f"Component '{comp_fqn}' does not provide IMnaContributor capability. Skipping MNA contribution.")
                                    
                            logger.debug(f"[{circuit.hierarchical_id}] All vectorized stamps pre-computed.")
                    
                            # --- END Phase 9 Task 5 Change ---
                    
                            # --- Main Frequency Loop (Lean Assembly) ---
                            # Crucially, this loop and its call to `assembler.assemble` REMAIN UNCHANGED
                            # from Phase 8. The assembler's role is now simply to slice the pre-computed
                            # vectorized data for the current frequency index. This preserves the high-performance
                            # architecture.
                            for idx, freq_val_hz in enumerate(freq_array_hz):
                                try:
                                    if np.isclose(freq_val_hz, 0.0):
                                        if dc_analysis_results and dc_analysis_results.get('Y_ports_dc') is not None and num_ac_ports > 0:
                                            y_matrices[idx] = _map_dc_y_to_ac_ports(dc_analysis_results, ac_port_names_ordered, dc_analyzer)
                                        continue
                    
                                    if assembler.node_count <= 1: continue
                                    
                                    Yn_full = assembler.assemble(idx, all_stamps_vectorized)
                                    
                                    if num_ac_ports == 0:
                                        y_matrices[idx] = np.empty((0, 0), dtype=np.complex128)
                                        continue
                    
                                    Yn_reduced = Yn_full[1:, 1:].tocsc()
                                    ext_indices_reduced = assembler.external_node_indices_reduced
                                    int_indices_reduced = assembler.internal_node_indices_reduced
                                    
                                    Y_EE = Yn_reduced[np.ix_(ext_indices_reduced, ext_indices_reduced)]
                                    if not int_indices_reduced:
                                        y_matrices[idx] = Y_EE.toarray()
                                    else:
                                        Y_EI = Yn_reduced[np.ix_(ext_indices_reduced, int_indices_reduced)]
                                        Y_IE = Yn_reduced[np.ix_(int_indices_reduced, ext_indices_reduced)]
                                        Y_II = Yn_reduced[np.ix_(int_indices_reduced, int_indices_reduced)]
                                        lu_II = factorize_mna_matrix(Y_II, freq_val_hz)
                                        X = lu_II.solve(Y_IE.toarray())
                                        y_matrices[idx] = Y_EE.toarray() - (Y_EI @ X)
                    
                                except (MnaInputError, SingularMatrixError, ComponentError, ParameterError) as e:
                                    logger.error(f"[{circuit.hierarchical_id}] AC simulation failed at {freq_val_hz:.4e} Hz: {e}")
                                    continue
                    
                            return {
                                'frequencies_hz': freq_array_hz,
                                'y_matrices': y_matrices,
                                'dc_results': dc_analysis_results,
                            }
                    
                        except (DCAnalysisError, MnaInputError, ComponentError, SingularMatrixError, ParameterError) as e:
                            raise SingleLevelSimulationFailure(
                                circuit_fqn=circuit.hierarchical_id,
                                circuit_source_path=circuit.source_file_path,
                                original_error=e,
                            ) from e
                    
                    
                    def _map_dc_y_to_ac_ports(
                        dc_results: Dict[str, Any], ac_port_names: List[str], dc_analyzer: DCAnalyzer
                    ) -> np.ndarray:
                        num_ac_ports = len(ac_port_names)
                        y_dc_qty = dc_results['Y_ports_dc']
                        dc_port_map = dc_results['dc_port_mapping']
                        y_dc_mag = y_dc_qty.to(ureg.siemens).magnitude
                        
                        y_mapped = np.zeros((num_ac_ports, num_ac_ports), dtype=np.complex128)
                    
                        ac_to_dc_idx_map = {ac_idx: dc_port_map.get(ac_name) for ac_idx, ac_name in enumerate(ac_port_names)}
                        for r_ac, r_dc in ac_to_dc_idx_map.items():
                            if r_dc is None: continue
                            for c_ac, c_dc in ac_to_dc_idx_map.items():
                                if c_dc is None: continue
                                y_mapped[r_ac, c_ac] = y_dc_mag[r_dc, c_dc]
                    
                        for ac_idx, ac_name in enumerate(ac_port_names):
                            if ac_to_dc_idx_map.get(ac_idx) is None:
                                srep = dc_analyzer.get_supernode_representative_name(ac_name)
                                if srep and dc_analyzer.is_ground_supernode_by_representative(srep):
                                    y_mapped[ac_idx, ac_idx] = LARGE_ADMITTANCE_SIEMENS
                    
                        return y_mapped
                    
                    
                    def _compute_subcircuit_cache_key(
                        sub_inst: SubcircuitInstance, freq_array_hz: np.ndarray, global_pm: ParameterManager
                    ) -> Tuple:
                        """Implements the definitive cache key algorithm for subcircuit simulation."""
                        # 1. Path to the definition file
                        def_path_str = str(sub_inst.sub_circuit_object.source_file_path)
                        
                        # 2. Canonical tuple of parameter overrides from the instance's YAML
                        overrides = sub_inst.raw_ir_data.raw_parameter_overrides
                        canonical_overrides_tuple = tuple(sorted(
                            (k, str(sorted(v.items()) if isinstance(v, dict) else v))
                            for k, v in overrides.items()
                        ))
                        
                        # 3. Get all external dependencies by querying the official ParameterManager API.
                        # This is the single source of truth for dependency information.
                        fqns_in_sub = {p.fqn for p in sub_inst.sub_circuit_object.parameter_manager.get_all_fqn_definitions()}
                        const_ext_deps, freq_ext_deps = global_pm.get_external_dependencies_of_scope(fqns_in_sub)
                    
                        # 4. Create a canonical tuple of the *values* of constant external dependencies.
                        ext_const_vals_tuple = tuple(sorted(
                            (fqn, f"{global_pm.get_constant_value(fqn):~P}") for fqn in const_ext_deps
                        ))
                        
                        # 5. Create a canonical tuple of the *definitions* of frequency-dependent external dependencies.
                        ext_freq_defs_tuple = tuple(sorted(
                            (p.fqn, p.raw_value_or_expression_str, p.declared_dimension_str)
                            for fqn in freq_ext_deps if (p := global_pm.get_parameter_definition(fqn))
                        ))
                        
                        external_context_tuple = (ext_const_vals_tuple, ext_freq_defs_tuple)
                        
                        # 6. Canonical tuple of the simulation frequencies
                        frequency_array_tuple = tuple(np.sort(np.unique(freq_array_hz)))
                        
                        # The final, correct, and robust cache key.
                        return (def_path_str, canonical_overrides_tuple, external_context_tuple, frequency_array_tuple)
                mna.py
                    # src/rfsim_core/simulation/mna.py
                    import logging
                    from itertools import product
                    
                    import numpy as np
                    import scipy.sparse as sp
                    from typing import Dict, List, Tuple, Optional, Set
                    
                    from ..data_structures import Circuit, Net
                    from ..parser.raw_data import ParsedLeafComponentData, ParsedSubcircuitData
                    from ..components.base import ComponentBase, ComponentError, StampInfo
                    from ..components.subcircuit import SubcircuitInstance
                    from ..units import ureg, Quantity
                    from ..parameters import ParameterManager, ParameterError
                    
                    logger = logging.getLogger(__name__)
                    
                    
                    class MnaInputError(ValueError):
                        """Error related to inputs for MNA assembly."""
                        pass
                    
                    
                    class MnaAssembler:
                        def __init__(self, circuit: Circuit, active_nets_override: Optional[Set[str]] = None):
                            if not isinstance(circuit, Circuit) or not circuit.raw_ir_root:
                                raise MnaInputError("Circuit object must be simulation-ready.")
                            
                            self.circuit_orig: Circuit = circuit 
                            self.ureg = ureg
                            self.parameter_manager: ParameterManager = circuit.parameter_manager
                    
                            self.active_nets_override: Optional[Set[str]] = active_nets_override
                            
                            self._effective_nets: Dict[str, Net] 
                            self._effective_sim_components_map: Dict[str, ComponentBase] 
                            self._effective_external_ports: Dict[str, Net] 
                            self._effective_ground_net_name: Optional[str] = None
                    
                            self._filter_circuit_elements() 
                    
                            self.node_map: Dict[str, int] = {}
                            self.node_count: int = 0
                            self.port_names: List[str] = [] 
                            self.port_indices: List[int] = [] 
                    
                            self._external_node_indices_reduced: List[int] = []
                            self._internal_node_indices_reduced: List[int] = []
                    
                            self._cached_rows: Optional[np.ndarray] = None
                            self._cached_cols: Optional[np.ndarray] = None
                            self._sparsity_nnz: int = 0
                            self._shape_full: Tuple[int, int] = (0, 0)
                            
                            self._assign_node_indices()      
                            self._identify_reduced_indices()  
                            self._compute_sparsity_pattern()  
                    
                            logger.info(f"MNA Assembler initialized for circuit '{self.circuit_orig.name}'.")
                    
                        @property
                        def effective_sim_components(self) -> Dict[str, ComponentBase]:
                            return self._effective_sim_components_map
                            
                        def _filter_circuit_elements(self):
                            if self.active_nets_override is None:
                                self._effective_nets = self.circuit_orig.nets
                                self._effective_sim_components_map = self.circuit_orig.sim_components
                                self._effective_external_ports = self.circuit_orig.external_ports
                                self._effective_ground_net_name = self.circuit_orig.ground_net_name
                                return
                    
                            active_nets_set = self.active_nets_override
                            self._effective_nets = {n: net for n, net in self.circuit_orig.nets.items() if n in active_nets_set}
                            self._effective_ground_net_name = self.circuit_orig.ground_net_name if self.circuit_orig.ground_net_name in active_nets_set else None
                            
                            self._effective_sim_components_map = {}
                            for comp_id, sim_comp in self.circuit_orig.sim_components.items():
                                raw_comp = sim_comp.raw_ir_data
                                connected_nets = set()
                                if isinstance(raw_comp, ParsedLeafComponentData):
                                    connected_nets.update(raw_comp.raw_ports_dict.values())
                                elif isinstance(raw_comp, ParsedSubcircuitData):
                                    connected_nets.update(raw_comp.raw_port_mapping.values())
                                
                                if connected_nets.issubset(active_nets_set):
                                    self._effective_sim_components_map[sim_comp.fqn] = sim_comp
                            
                            self._effective_external_ports = {n: net for n, net in self.circuit_orig.external_ports.items() if n in active_nets_set}
                    
                        def _assign_node_indices(self):
                            if not self._effective_nets:
                                self.node_count = 0
                                self.port_names, self.port_indices = [], []
                                self._shape_full = (0, 0)
                                return
                    
                            self.node_map = {}
                            idx = 0
                            if self._effective_ground_net_name:
                                self.node_map[self._effective_ground_net_name] = idx
                                idx += 1
                            
                            for net_name in sorted(self._effective_nets.keys()):
                                if net_name not in self.node_map:
                                    self.node_map[net_name] = idx
                                    idx += 1
                            
                            self.node_count = idx
                            self._shape_full = (idx, idx)
                            self.port_names = sorted(self._effective_external_ports.keys())
                            self.port_indices = [self.node_map[name] for name in self.port_names]
                    
                        def _identify_reduced_indices(self):
                            if self.node_count <= 1:
                                self._external_node_indices_reduced, self._internal_node_indices_reduced = [], []
                                return
                    
                            ground_is_zero = self._effective_ground_net_name is not None
                            all_indices_set = set(range(self.node_count))
                            port_indices_set = set(self.port_indices)
                            
                            if ground_is_zero:
                                all_indices_set.remove(0)
                                port_indices_set.discard(0)
                            
                            reduced_map = {full_idx: (full_idx - 1 if ground_is_zero else full_idx) for full_idx in all_indices_set}
                            self._external_node_indices_reduced = sorted([reduced_map[i] for i in port_indices_set])
                            internal_indices_set = all_indices_set - port_indices_set
                            self._internal_node_indices_reduced = sorted([reduced_map[i] for i in internal_indices_set])
                    
                        @property
                        def external_node_indices_reduced(self) -> List[int]: return self._external_node_indices_reduced
                        
                        @property
                        def internal_node_indices_reduced(self) -> List[int]: return self._internal_node_indices_reduced
                    
                        def _add_to_coo_pattern(self, rows: list, cols: list, r: int, c: int):
                            rows.append(r); cols.append(c)
                    
                        def _compute_sparsity_pattern(self):
                            rows, cols = [], []
                            if self.node_count == 0:
                                self._cached_rows, self._cached_cols, self._sparsity_nnz = np.array([], dtype=int), np.array([], dtype=int), 0
                                return
                    
                            for sim_comp in self._effective_sim_components_map.values():
                                if isinstance(sim_comp, SubcircuitInstance):
                                    indices = {self.node_map[n] for n in sim_comp.raw_ir_data.raw_port_mapping.values() if n in self.node_map}
                                    for r, c in product(sorted(list(indices)), repeat=2):
                                        self._add_to_coo_pattern(rows, cols, r, c)
                                else:
                                    raw_comp = sim_comp.raw_ir_data
                                    for p1, p2 in type(sim_comp).declare_connectivity():
                                        n1_name = raw_comp.raw_ports_dict.get(p1, raw_comp.raw_ports_dict.get(str(p1)))
                                        n2_name = raw_comp.raw_ports_dict.get(p2, raw_comp.raw_ports_dict.get(str(p2)))
                                        if n1_name in self.node_map and n2_name in self.node_map:
                                            n1, n2 = self.node_map[n1_name], self.node_map[n2_name]
                                            self._add_to_coo_pattern(rows, cols, n1, n1)
                                            self._add_to_coo_pattern(rows, cols, n2, n2)
                                            if n1 != n2:
                                                self._add_to_coo_pattern(rows, cols, n1, n2)
                                                self._add_to_coo_pattern(rows, cols, n2, n1)
                    
                            temp_coo = sp.coo_matrix((np.ones_like(rows), (rows, cols)), shape=self._shape_full)
                            final_coo = temp_coo.tocsc().tocoo()
                            self._cached_rows, self._cached_cols, self._sparsity_nnz = final_coo.row, final_coo.col, final_coo.nnz
                    
                        def assemble(self, current_sweep_idx: int, all_stamps_vectorized: Dict[str, List[StampInfo]]) -> sp.csc_matrix:
                            if self._cached_rows is None: raise RuntimeError("Sparsity pattern not computed.")
                            if self.node_count == 0: return sp.csc_matrix((0, 0), dtype=np.complex128)
                    
                            mna_data = np.zeros(self._sparsity_nnz, dtype=np.complex128)
                            rc_to_data_idx = {(r, c): i for i, (r, c) in enumerate(zip(self._cached_rows, self._cached_cols))}
                    
                            def add_value(r, c, value, comp_fqn):
                                if (key := rc_to_data_idx.get((r, c))) is not None:
                                    mna_data[key] += value
                                elif abs(value) > 1e-15:
                                    raise MnaInputError(f"Comp '{comp_fqn}' tried to stamp ({value:.3e}) at ({r},{c}), outside sparsity.")
                    
                            for comp_fqn, sim_comp in self._effective_sim_components_map.items():
                                try:
                                    stamp_infos = all_stamps_vectorized[comp_fqn]
                                    
                                    for stamp_matrix_qty, port_ids_yaml in stamp_infos:
                                        # Slice the correct per-frequency matrix from the pre-computed vectorized stamp
                                        stamp_matrix_scalar = stamp_matrix_qty.magnitude[current_sweep_idx]
                                        
                                        raw_comp = sim_comp.raw_ir_data
                                        port_map = raw_comp.raw_port_mapping if isinstance(raw_comp, ParsedSubcircuitData) else raw_comp.raw_ports_dict
                                        
                                        global_indices = [self.node_map[port_map[pid]] for pid in port_ids_yaml]
                                        
                                        for i, r_idx in enumerate(global_indices):
                                            for j, c_idx in enumerate(global_indices):
                                                add_value(r_idx, c_idx, stamp_matrix_scalar[i, j], comp_fqn)
                    
                                except Exception as e:
                                    raise ComponentError(f"Stamping failed for '{comp_fqn}' at sweep index {current_sweep_idx}: {e}") from e
                    
                            Yn_full_coo = sp.coo_matrix((mna_data, (self._cached_rows, self._cached_cols)), shape=self._shape_full)
                            return Yn_full_coo.tocsc()
                solver.py
                    # src/rfsim_core/simulation/solver.py
                    import logging
                    import numpy as np
                    import scipy.sparse as sp
                    import scipy.sparse.linalg as splinalg
                    from typing import Optional
                    
                    from .exceptions import SingularMatrixError
                    
                    logger = logging.getLogger(__name__)
                    
                    def factorize_mna_matrix(Yn_reduced: sp.csc_matrix, frequency: float) -> splinalg.SuperLU:
                        """
                        Factorizes the reduced MNA matrix using sparse LU decomposition.
                    
                        Args:
                            Yn_reduced: The (N-1) x (N-1) reduced MNA matrix (CSC format).
                            frequency: The frequency at which the factorization is being performed, for context.
                    
                        Returns:
                            The LU factorization object (splinalg.SuperLU).
                    
                        Raises:
                            SingularMatrixError: A diagnosable error if the matrix is singular.
                            TypeError: If input is not a sparse matrix.
                        """
                        if not sp.isspmatrix(Yn_reduced):
                            raise TypeError("Input Yn_reduced must be a SciPy sparse matrix.")
                        if Yn_reduced.shape[0] != Yn_reduced.shape[1]:
                            raise ValueError("Reduced MNA matrix must be square.")
                    
                        logger.debug(f"Factorizing reduced MNA matrix ({Yn_reduced.shape}) at {frequency:.4e} Hz...")
                        try:
                            lu = splinalg.splu(Yn_reduced.tocsc())
                            logger.debug("LU factorization successful.")
                            return lu
                        except RuntimeError as e:
                            logger.error(f"LU factorization failed at {frequency:.4e} Hz, matrix appears singular: {e}")
                            raise SingularMatrixError(details=str(e), frequency=frequency) from e
                        except Exception as e:
                            logger.error(f"Unexpected error during LU factorization at {frequency:.4e} Hz: {e}", exc_info=True)
                            raise e
                    
                    def solve_mna_system(lu_factorization: splinalg.SuperLU, I_reduced: np.ndarray) -> np.ndarray:
                        """
                        Solves the reduced MNA system using a pre-computed LU factorization.
                        """
                        # (Implementation of this function remains the same as proposed previously,
                        # raising ValueError/TypeError for bad inputs.)
                        if not isinstance(lu_factorization, splinalg.SuperLU):
                            raise TypeError("lu_factorization must be a SuperLU object from splinalg.splu.")
                        
                        logger.debug("Solving reduced MNA system using LU factorization...")
                        V_reduced = lu_factorization.solve(I_reduced)
                    
                        if np.any(np.isnan(V_reduced)) or np.any(np.isinf(V_reduced)):
                            logger.error("NaN or Inf detected in MNA solution vector.")
                            raise SingularMatrixError(details="MNA system solve resulted in NaN/Inf values.", frequency=None) # No freq context here
                            
                        return V_reduced
            units.py
                # --- Modify: src/rfsim_core/units.py ---
                import pint
                import logging
                
                logger = logging.getLogger(__name__)
                ureg = pint.UnitRegistry()
                Quantity = ureg.Quantity
                logger.info("Pint Unit Registry initialized.")
                
                
                # Define [admittance] dimension to align with project terminology.
                # This relates the name '[admittance]' to the physical dimension of current/voltage.
                ureg.define("[admittance] = [current] / [voltage]")
                
                # Define [impedance] dimension to align with project terminology.
                ureg.define("[impedance] = [voltage] / [current]")
                
                # --- Canonical dimensionality objects for explicit checks ---
                # These store the frozendict representation of the dimensions.
                ADMITTANCE_DIMENSIONALITY = ureg.parse_expression('siemens').dimensionality
                IMPEDANCE_DIMENSIONALITY = ureg.parse_expression('ohm').dimensionality
                
                logger.debug(f"Defined canonical dimensionalities: ADMITTANCE_DIMENSIONALITY, IMPEDANCE_DIMENSIONALITY")
                
                # If __all__ is used in this file, add them:
                # __all__ = ["ureg", "Quantity", "ADMITTANCE_DIMENSIONALITY", "IMPEDANCE_DIMENSIONALITY"]
            validation/
                __init__.py
                    # src/rfsim_core/validation/__init__.py
                    import logging
                    logger = logging.getLogger(__name__)
                    
                    from .issues import ValidationIssue, ValidationIssueLevel
                    from .issue_codes import SemanticIssueCode
                    from .semantic_validator import SemanticValidator
                    from .exceptions import SemanticValidationError
                    
                    __all__ = [
                        "ValidationIssue",
                        "ValidationIssueLevel",
                        "SemanticIssueCode",
                        "SemanticValidator",
                        "SemanticValidationError",
                    ]
                exceptions.py
                    # src/rfsim_core/validation/exceptions.py
                    from typing import List
                    
                    from .issues import ValidationIssue
                    from ..errors import Diagnosable, format_diagnostic_report
                    
                    class SemanticValidationError(ValueError, Diagnosable):
                        """
                        Custom exception raised when semantic validation detects one or more errors.
                        Contains a list of all error-level ValidationIssue objects and is diagnosable.
                        """
                        def __init__(self, issues: List[ValidationIssue]):
                            self.issues: List[ValidationIssue] = [
                                issue for issue in issues if issue.level == "ERROR"
                            ]
                            error_lines = [str(issue) for issue in self.issues]
                            summary_message = (
                                f"Semantic validation failed with {len(self.issues)} error(s):\n"
                                + "\n".join(f"  - {line}" for line in error_lines)
                            )
                            super().__init__(summary_message)
                        
                        def get_diagnostic_report(self) -> str:
                            """Generates a report that lists all validation errors."""
                            error_lines = [str(issue) for issue in self.issues]
                            details = (
                                f"One or more logical errors were found in the circuit definition.\n"
                                f"Found {len(self.issues)} error(s). See details below:\n\n"
                                + "\n".join(f"  - {line}" for line in error_lines)
                            )
                            
                            first_issue = self.issues[0] if self.issues else None
                            context = {}
                            if first_issue:
                                context['fqn'] = first_issue.component_fqn or first_issue.hierarchical_context or 'Multiple'
                                # Assuming ValidationIssue.details might contain the source path
                                if hasattr(first_issue, 'details') and (source_path := first_issue.details.get('source_yaml_path')):
                                     context['source_file'] = source_path
                            
                            return format_diagnostic_report(
                                error_type="Circuit Semantic Validation Error",
                                details=details,
                                suggestion="Review and correct all validation errors listed above in the circuit netlist(s).",
                                context=context
                            )
                issue_codes.py
                    # src/rfsim_core/validation/issue_codes.py
                    import logging
                    from enum import Enum
                    from typing import Tuple
                    
                    logger = logging.getLogger(__name__)
                    
                    
                    class SemanticIssueCode(Enum):
                        """
                        Registry of semantic validation issue codes and their message templates.
                        Each enum member's value is a tuple: (code_str, message_template_str).
                        """
                    
                        # --- Net Connectivity Issues (NET_CONN_...) ---
                        NET_CONN_001 = ("NET_CONN_001", "Internal net '{net_name}' is defined but has no component connections (completely floating).")
                        NET_CONN_002 = ("NET_CONN_002", "Internal net '{net_name}' has only a single connection to component '{connected_to_component}' port '{connected_to_port}'.")
                    
                        # --- Component Type & Port Issues (COMP_...) ---
                        COMP_TYPE_001 = ("COMP_TYPE_001", "Component '{component_fqn}' specifies an unregistered type '{component_type}'. Available types: {available_types}.")
                        COMP_LEAF_PORT_DEF_UNDECLARED = ("COMP_LEAF_PORT_DEF_UNDECLARED", "Component '{component_fqn}' uses undeclared port(s): {extra_ports}. Declared ports are: {declared_ports}.")
                        COMP_LEAF_PORT_DEF_MISSING = ("COMP_LEAF_PORT_DEF_MISSING", "Component '{component_fqn}' is missing required connections for port(s): {missing_ports}. All declared ports are: {declared_ports}.")
                    
                        # --- External Port Issues (EXT_PORT_...) ---
                        EXT_PORT_001 = ("EXT_PORT_001", "External port '{net_name}' cannot be the ground net.")
                        EXT_PORT_002 = ("EXT_PORT_002", "External port net '{net_name}' has no component connections.")
                        EXT_PORT_Z0_MISSING = ("EXT_PORT_Z0_MISSING", "External port '{net_name}' reference impedance (Z0) string is missing or empty.")
                        EXT_PORT_Z0_DIM_MISMATCH = ("EXT_PORT_Z0_DIM_MISMATCH", "External port '{net_name}' Z0 literal '{value}' has dimensionality '{parsed_dimensionality}', which is not compatible with ohms.")
                    
                        # --- Ground Net Issues (GND_...) ---
                        GND_CONN_001 = ("GND_CONN_001", "Ground net '{net_name}' has no component connections, although components exist in the circuit.")
                    
                        # --- Leaf Component Parameter Issues (PARAM_...) ---
                        PARAM_LEAF_UNDCL = ("PARAM_LEAF_UNDCL", "Component '{component_fqn}' defines parameter '{parameter_name}' which is not declared by its type. Declared parameters are: {declared_params}.")
                        PARAM_LEAF_MISSING = ("PARAM_LEAF_MISSING", "Component '{component_fqn}' is missing required parameter '{parameter_name}'. All declared parameters are: {declared_params}.")
                        PARAM_LEAF_DIM_MISMATCH = ("PARAM_LEAF_DIM_MISMATCH", "Constant value for parameter '{parameter_name}' of component '{component_fqn}' (resolved to '{resolved_value_str}') is not dimensionally compatible with the expected dimension '{expected_dim_str}'.")
                    
                        # --- Subcircuit Instantiation Issues (SUB_INST_...) ---
                        SUB_INST_PORT_MAP_UNDECLARED = ("SUB_INST_PORT_MAP_UNDECLARED", "Subcircuit instance '{instance_fqn}' maps port '{undeclared_sub_port_name}', which is not an external port of its definition '{sub_def_name}'. Available ports: {available_sub_ports}.")
                        SUB_INST_PORT_MAP_MISSING = ("SUB_INST_PORT_MAP_MISSING", "Subcircuit instance '{instance_fqn}' fails to map required external port(s) from its definition '{sub_def_name}': {missing_sub_ports}.")
                        SUB_INST_PORT_MAP_REQUIRED = ("SUB_INST_PORT_MAP_REQUIRED", "Subcircuit instance '{instance_fqn}' must include a 'ports' block because its definition '{sub_def_name}' declares external ports.")
                        SUB_INST_PARAM_OVERRIDE_UNDECLARED = ("SUB_INST_PARAM_OVERRIDE_UNDECLARED", "Subcircuit instance '{instance_fqn}' attempts to override parameter '{override_target_in_sub}', which does not exist in the subcircuit definition.")
                        SUB_INST_PARAM_OVERRIDE_DIM_MISMATCH = ("SUB_INST_PARAM_OVERRIDE_DIM_MISMATCH", "Subcircuit instance '{instance_fqn}' provides override value '{override_value_str}' for parameter '{override_target_in_sub}'. The value's dimension ('{provided_dim_str}') is incompatible with the parameter's declared dimension ('{expected_dim_str}').")
                    
                        # --- Ideal DC Path Identification Info (DC_INFO_...) ---
                        DC_INFO_SHORT_R0 = ("DC_INFO_SHORT_R0", "Component '{component_fqn}' (Resistor) with value {value_str} will be treated as an ideal DC short.")
                        DC_INFO_SHORT_L0 = ("DC_INFO_SHORT_L0", "Component '{component_fqn}' (Inductor) with value {value_str} will be treated as an ideal DC short.")
                        DC_INFO_OPEN_LINF = ("DC_INFO_OPEN_LINF", "Component '{component_fqn}' (Inductor) with value {value_str} will be treated as an ideal DC open.")
                        DC_INFO_SHORT_CINF = ("DC_INFO_SHORT_CINF", "Component '{component_fqn}' (Capacitor) with value {value_str} will be treated as an ideal DC short.")
                        DC_INFO_OPEN_C0 = ("DC_INFO_OPEN_C0", "Component '{component_fqn}' (Capacitor) with value {value_str} will be treated as an ideal DC open.")
                    
                        @property
                        def code(self) -> str:
                            return self.value[0]
                    
                        @property
                        def template(self) -> str:
                            return self.value[1]
                    
                        def format_message(self, **kwargs) -> str:
                            """Formats the message template with provided keyword arguments."""
                            try:
                                return self.template.format(**kwargs)
                            except KeyError as e:
                                logger.error(f"Missing key {e} for formatting message template of {self.name} (code: {self.code}): '{self.template}'. Provided args: {kwargs}")
                                return f"Error formatting message for {self.code}: Missing key {e}. Template: '{self.template}' Args: {kwargs}"
                issues.py
                    # src/rfsim_core/validation/issues.py
                    import logging
                    from enum import Enum
                    from dataclasses import dataclass, field
                    from typing import Optional, Dict, Any
                    
                    logger = logging.getLogger(__name__)
                    
                    
                    class ValidationIssueLevel(Enum):
                        """Severity level of a validation issue."""
                        ERROR = "ERROR"
                        WARNING = "WARNING"
                        INFO = "INFO"
                    
                        def __str__(self):
                            return self.value
                    
                    
                    @dataclass
                    class ValidationIssue:
                        """
                        Represents a single validation issue found during semantic checks.
                        Includes full hierarchical context for actionable diagnostics.
                        """
                        level: ValidationIssueLevel
                        code: str
                        message: str
                        component_fqn: Optional[str] = None
                        hierarchical_context: Optional[str] = None
                        details: Dict[str, Any] = field(default_factory=dict)
                    
                        def __str__(self) -> str:
                            parts = [f"[{self.level.name} - {self.code}]"]
                            if self.hierarchical_context:
                                parts.append(f"Context: {self.hierarchical_context}")
                            if self.component_fqn:
                                parts.append(f"Component: {self.component_fqn}")
                            parts.append(f"Message: {self.message}")
                    
                            if self.details:
                                filtered_details = {
                                    k: v for k, v in self.details.items()
                                    if k not in ['instance_fqn', 'hierarchical_context', 'component_fqn']
                                }
                                if filtered_details:
                                    details_str = ", ".join(f"{k}={v}" for k, v in sorted(filtered_details.items()))
                                    parts.append(f"Details: ({details_str})")
                    
                            return " ".join(parts)
                semantic_validator.py
                    # src/rfsim_core/validation/semantic_validator.py
                    import logging
                    from typing import List, Dict, Any, Optional, Set, Tuple
                    
                    import numpy as np
                    import pint
                    
                    from ..data_structures import Circuit
                    from ..units import ureg, Quantity
                    from .issues import ValidationIssue, ValidationIssueLevel
                    from .issue_codes import SemanticIssueCode
                    from ..components import COMPONENT_REGISTRY, ComponentBase, Resistor, Capacitor, Inductor
                    from ..components.subcircuit import SubcircuitInstance
                    from ..parameters import ParameterManager, ParameterScopeError, ParameterError
                    from ..parser.raw_data import ParsedLeafComponentData, ParsedSubcircuitData
                    
                    
                    logger = logging.getLogger(__name__)
                    
                    
                    class SemanticValidationError(ValueError):
                        """
                        Custom exception raised when semantic validation detects one or more errors.
                        Contains a list of all error-level ValidationIssue objects.
                        """
                        def __init__(self, issues: List[ValidationIssue]):
                            self.issues: List[ValidationIssue] = [
                                issue for issue in issues if issue.level == ValidationIssueLevel.ERROR
                            ]
                            error_lines = [str(issue) for issue in self.issues]
                            summary_message = (
                                f"Semantic validation failed with {len(self.issues)} error(s):\n"
                                + "\n".join(f"  - {line}" for line in error_lines)
                            )
                            super().__init__(summary_message)
                    
                    
                    class SemanticValidator:
                        """
                        Performs recursive semantic validation on a synthesized, hierarchical circuit model.
                        """
                    
                        def __init__(self, top_level_circuit: Circuit):
                            if not isinstance(top_level_circuit, Circuit):
                                raise TypeError("SemanticValidator requires a valid top-level Circuit object.")
                            if not top_level_circuit.parameter_manager:
                                raise ValueError("Top-level Circuit object has an uninitialized ParameterManager.")
                    
                            self.top_level_circuit = top_level_circuit
                            self.issues: List[ValidationIssue] = []
                            self._ureg = ureg
                            self.pm: ParameterManager = top_level_circuit.parameter_manager
                            self._validated_circuit_defs: Set[str] = set()
                    
                        def validate(self) -> List[ValidationIssue]:
                            """Public entry point to start the recursive validation process."""
                            self.issues = []
                            self._validated_circuit_defs.clear()
                            logger.info(f"Starting recursive semantic validation for '{self.top_level_circuit.name}'...")
                            self._validate_recursive(self.top_level_circuit)
                    
                            if self.issues:
                                errors = sum(1 for i in self.issues if i.level == ValidationIssueLevel.ERROR)
                                warnings = sum(1 for i in self.issues if i.level == ValidationIssueLevel.WARNING)
                                infos = sum(1 for i in self.issues if i.level == ValidationIssueLevel.INFO)
                                logger.info(f"Validation complete. Found: {errors} errors, {warnings} warnings, {infos} info messages.")
                            else:
                                logger.info("Validation complete with no issues found.")
                                
                            return self.issues
                    
                        def _add_issue(self, level: ValidationIssueLevel, code_enum: SemanticIssueCode, **kwargs):
                            """Helper to create and add a ValidationIssue with full context."""
                            comp_fqn = kwargs.get('component_fqn', kwargs.get('instance_fqn'))
                            h_context = kwargs.get('hierarchical_context')
                            
                            if comp_fqn and 'component_fqn' not in kwargs:
                                 kwargs['component_fqn'] = comp_fqn
                    
                            message = code_enum.format_message(**kwargs)
                            self.issues.append(ValidationIssue(
                                level=level, code=code_enum.code, message=message,
                                component_fqn=comp_fqn, hierarchical_context=h_context, details=kwargs
                            ))
                    
                        def _validate_recursive(self, circuit_node: Circuit):
                            """The core recursive validation function."""
                            def_path_str = str(circuit_node.source_file_path)
                            if def_path_str not in self._validated_circuit_defs:
                                logger.debug(f"Validating context for '{circuit_node.hierarchical_id}' defined in '{def_path_str}'")
                                self._check_nets_in_context(circuit_node)
                                self._check_external_ports_in_context(circuit_node)
                                self._validated_circuit_defs.add(def_path_str)
                    
                            for sim_comp in circuit_node.sim_components.values():
                                if isinstance(sim_comp, SubcircuitInstance):
                                    self._check_subcircuit_instance(sim_comp)
                                    self._validate_recursive(sim_comp.sub_circuit_object)
                                elif isinstance(sim_comp, ComponentBase):
                                    self._check_leaf_component_instance(sim_comp)
                                else:
                                    logger.warning(f"Object '{sim_comp.instance_id}' in sim_components is not a ComponentBase; skipping validation.")
                    
                        # --- Helper Methods ---
                        
                        def _get_net_connection_counts(self, circuit_node: Circuit) -> Dict[str, List[Tuple[str, str]]]:
                            """
                            Helper to compute net connection lists for a specific circuit context.
                            Returns a map from net_name -> list of (component_fqn, port_id) tuples.
                            """
                            connections: Dict[str, List[Tuple[str, str]]] = {}
                            
                            for sim_comp in circuit_node.sim_components.values():
                                ports_map = {}
                                if hasattr(sim_comp, 'raw_ir_data'):
                                    if isinstance(sim_comp, SubcircuitInstance):
                                        ports_map = sim_comp.raw_ir_data.raw_port_mapping
                                    elif isinstance(sim_comp.raw_ir_data, ParsedLeafComponentData):
                                        ports_map = sim_comp.raw_ir_data.raw_ports_dict
                                
                                for port_name, connected_net in ports_map.items():
                                    if connected_net in circuit_node.nets:
                                        if connected_net not in connections:
                                            connections[connected_net] = []
                                        connections[connected_net].append((sim_comp.fqn, str(port_name)))
                            return connections
                    
                        # --- Context-Level Checks (Run once per circuit definition) ---
                        
                        def _check_nets_in_context(self, circuit_node: Circuit):
                            """Validates nets for a given circuit definition."""
                            net_connections = self._get_net_connection_counts(circuit_node)
                            internal_nets = set(circuit_node.nets.keys()) - set(circuit_node.external_ports.keys()) - {circuit_node.ground_net_name}
                    
                            for net_name in internal_nets:
                                connections = net_connections.get(net_name, [])
                                count = len(connections)
                                if count == 0:
                                    self._add_issue(ValidationIssueLevel.WARNING, SemanticIssueCode.NET_CONN_001,
                                                    net_name=net_name, hierarchical_context=circuit_node.hierarchical_id)
                                elif count == 1:
                                    comp_fqn, port = connections[0]
                                    self._add_issue(ValidationIssueLevel.WARNING, SemanticIssueCode.NET_CONN_002,
                                                    net_name=net_name, hierarchical_context=circuit_node.hierarchical_id,
                                                    connected_to_component=comp_fqn, connected_to_port=port)
                            
                            if circuit_node.sim_components and len(net_connections.get(circuit_node.ground_net_name, [])) == 0:
                                self._add_issue(ValidationIssueLevel.WARNING, SemanticIssueCode.GND_CONN_001,
                                                net_name=circuit_node.ground_net_name, hierarchical_context=circuit_node.hierarchical_id)
                    
                        def _check_external_ports_in_context(self, circuit_node: Circuit):
                            """Validates the external port definitions of a circuit definition, including Z0."""
                            net_connections = self._get_net_connection_counts(circuit_node)
                            raw_ports_info = {p['id']: p for p in circuit_node.raw_ir_root.raw_external_ports_list}
                    
                            for port_name in circuit_node.external_ports:
                                if port_name == circuit_node.ground_net_name:
                                    self._add_issue(ValidationIssueLevel.ERROR, SemanticIssueCode.EXT_PORT_001,
                                                    net_name=port_name, hierarchical_context=circuit_node.hierarchical_id)
                                if len(net_connections.get(port_name, [])) == 0:
                                    self._add_issue(ValidationIssueLevel.ERROR, SemanticIssueCode.EXT_PORT_002,
                                                    net_name=port_name, hierarchical_context=circuit_node.hierarchical_id)
                    
                                z0_str = raw_ports_info.get(port_name, {}).get('reference_impedance')
                                if not z0_str:
                                    self._add_issue(ValidationIssueLevel.ERROR, SemanticIssueCode.EXT_PORT_Z0_MISSING,
                                                    net_name=port_name, hierarchical_context=circuit_node.hierarchical_id)
                                    continue
                                
                                try:
                                    qty = self._ureg.Quantity(z0_str)
                                    if not qty.is_compatible_with("ohm"):
                                        self._add_issue(ValidationIssueLevel.ERROR, SemanticIssueCode.EXT_PORT_Z0_DIM_MISMATCH,
                                                        net_name=port_name, hierarchical_context=circuit_node.hierarchical_id,
                                                        value=z0_str, parsed_dimensionality=str(qty.dimensionality))
                                except (pint.UndefinedUnitError, pint.DimensionalityError, ValueError):
                                    pass # Assume it's a parameter reference; PM build failure is the source of truth for invalid refs.
                    
                        # --- Instance-Level Checks ---
                    
                        def _check_leaf_component_instance(self, sim_comp: ComponentBase):
                            """Validates a single leaf component instance (R, L, C, etc.)."""
                            try:
                                assert hasattr(sim_comp, 'raw_ir_data') and isinstance(sim_comp.raw_ir_data, ParsedLeafComponentData), \
                                       f"Internal Contract Violated: Leaf component '{sim_comp.fqn}' is missing its 'raw_ir_data' link."
                            except AssertionError as e:
                                raise TypeError(str(e)) from e
                    
                            comp_ir = sim_comp.raw_ir_data
                            
                            if sim_comp.component_type not in COMPONENT_REGISTRY:
                                self._add_issue(ValidationIssueLevel.ERROR, SemanticIssueCode.COMP_TYPE_001,
                                                component_fqn=sim_comp.fqn, component_type=sim_comp.component_type,
                                                available_types=list(COMPONENT_REGISTRY.keys()))
                                return
                    
                            declared_ports = {str(p) for p in type(sim_comp).declare_ports()}
                            used_ports = {str(p) for p in comp_ir.raw_ports_dict.keys()}
                            
                            if extra := sorted(list(used_ports - declared_ports)):
                                self._add_issue(ValidationIssueLevel.ERROR, SemanticIssueCode.COMP_LEAF_PORT_DEF_UNDECLARED,
                                                component_fqn=sim_comp.fqn, extra_ports=extra, declared_ports=sorted(list(declared_ports)))
                            if missing := sorted(list(declared_ports - used_ports)):
                                self._add_issue(ValidationIssueLevel.ERROR, SemanticIssueCode.COMP_LEAF_PORT_DEF_MISSING,
                                                component_fqn=sim_comp.fqn, missing_ports=missing, declared_ports=sorted(list(declared_ports)))
                    
                            declared_params = type(sim_comp).declare_parameters()
                            declared_names = set(declared_params.keys())
                            provided_names = set(comp_ir.raw_parameters_dict.keys())
                    
                            if undeclared := sorted(list(provided_names - declared_names)):
                                self._add_issue(ValidationIssueLevel.ERROR, SemanticIssueCode.PARAM_LEAF_UNDCL,
                                                component_fqn=sim_comp.fqn, parameter_name=undeclared[0], declared_params=sorted(list(declared_names)))
                            if missing := sorted(list(declared_names - provided_names)):
                                self._add_issue(ValidationIssueLevel.ERROR, SemanticIssueCode.PARAM_LEAF_MISSING,
                                                component_fqn=sim_comp.fqn, parameter_name=missing[0], declared_params=sorted(list(declared_names)))
                    
                            for name, expected_dim in declared_params.items():
                                param_fqn = f"{sim_comp.fqn}.{name}"
                                if self.pm.is_constant(param_fqn):
                                    try:
                                        const_val = self.pm.get_constant_value(param_fqn)
                                        if not const_val.is_compatible_with(expected_dim):
                                            self._add_issue(ValidationIssueLevel.ERROR, SemanticIssueCode.PARAM_LEAF_DIM_MISMATCH,
                                                            component_fqn=sim_comp.fqn, parameter_name=name,
                                                            resolved_value_str=f"{const_val:~P}", expected_dim_str=expected_dim)
                                        self._check_and_report_dc_behavior(sim_comp, name, const_val)
                                    except ParameterError:
                                        pass
                    
                        def _check_subcircuit_instance(self, sub_inst: SubcircuitInstance):
                            """Performs the subcircuit-specific validation checks."""
                            sub_def = sub_inst.sub_circuit_object
                            instance_ir = sub_inst.raw_ir_data
                            instance_fqn = sub_inst.fqn
                    
                            declared_sub_ports = set(sub_def.external_ports.keys())
                            mapped_sub_ports = set(instance_ir.raw_port_mapping.keys())
                    
                            if declared_sub_ports and not instance_ir.raw_port_mapping:
                                self._add_issue(ValidationIssueLevel.ERROR, SemanticIssueCode.SUB_INST_PORT_MAP_REQUIRED,
                                                instance_fqn=instance_fqn, sub_def_name=sub_def.name)
                                return
                    
                            if undeclared := sorted(list(mapped_sub_ports - declared_sub_ports)):
                                self._add_issue(ValidationIssueLevel.ERROR, SemanticIssueCode.SUB_INST_PORT_MAP_UNDECLARED,
                                                instance_fqn=instance_fqn, undeclared_sub_port_name=undeclared[0],
                                                sub_def_name=sub_def.name, available_sub_ports=sorted(list(declared_sub_ports)))
                            if missing := sorted(list(declared_sub_ports - mapped_sub_ports)):
                                self._add_issue(ValidationIssueLevel.ERROR, SemanticIssueCode.SUB_INST_PORT_MAP_MISSING,
                                                instance_fqn=instance_fqn, sub_def_name=sub_def.name, missing_sub_ports=missing)
                    
                            for key, value in instance_ir.raw_parameter_overrides.items():
                                target_fqn_in_sub = f"{sub_inst.fqn}.{key}"
                                try:
                                    p_def = self.pm.get_parameter_definition(target_fqn_in_sub)
                                    if not isinstance(value, dict):
                                        try:
                                            qty = self._ureg.Quantity(str(value))
                                            if not qty.is_compatible_with(p_def.declared_dimension_str):
                                                self._add_issue(ValidationIssueLevel.ERROR, SemanticIssueCode.SUB_INST_PARAM_OVERRIDE_DIM_MISMATCH,
                                                                instance_fqn=instance_fqn, override_target_in_sub=key,
                                                                override_value_str=str(value), provided_dim_str=str(qty.dimensionality),
                                                                expected_dim_str=p_def.declared_dimension_str)
                                        except (pint.UndefinedUnitError, ValueError):
                                            pass
                                except ParameterScopeError:
                                    self._add_issue(ValidationIssueLevel.ERROR, SemanticIssueCode.SUB_INST_PARAM_OVERRIDE_UNDECLARED,
                                                    instance_fqn=instance_fqn, override_target_in_sub=key)
                    
                        def _check_and_report_dc_behavior(self, sim_comp: ComponentBase, param_name: str, value_qty: Quantity):
                            """Adds INFO issues for components that are ideal DC shorts or opens."""
                            comp_fqn = sim_comp.fqn
                            value_str = f"{value_qty:~P}"
                            mag = value_qty.magnitude
                    
                            if isinstance(sim_comp, Resistor) and param_name == "resistance" and mag == 0:
                                self._add_issue(ValidationIssueLevel.INFO, SemanticIssueCode.DC_INFO_SHORT_R0, component_fqn=comp_fqn, value_str=value_str)
                            elif isinstance(sim_comp, Inductor) and param_name == "inductance":
                                if mag == 0:
                                    self._add_issue(ValidationIssueLevel.INFO, SemanticIssueCode.DC_INFO_SHORT_L0, component_fqn=comp_fqn, value_str=value_str)
                                elif np.isposinf(mag):
                                    self._add_issue(ValidationIssueLevel.INFO, SemanticIssueCode.DC_INFO_OPEN_LINF, component_fqn=comp_fqn, value_str=value_str)
                            elif isinstance(sim_comp, Capacitor) and param_name == "capacitance":
                                if mag == 0:
                                    self._add_issue(ValidationIssueLevel.INFO, SemanticIssueCode.DC_INFO_OPEN_C0, component_fqn=comp_fqn, value_str=value_str)
                                elif np.isposinf(mag):
                                    self._add_issue(ValidationIssueLevel.INFO, SemanticIssueCode.DC_INFO_SHORT_CINF, component_fqn=comp_fqn, value_str=value_str)

---